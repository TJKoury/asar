global["asarPatch"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading wasm modules
/******/ 	var installedWasmModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// object with all compiled WebAssembly.Modules
/******/ 	__webpack_require__.w = {};
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/monkeypatch/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/asar.js":
/*!*********************!*\
  !*** ./lib/asar.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst minimatch = __webpack_require__(/*! minimatch */ \"./node_modules/minimatch/minimatch.js\")\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\")\n\nconst Filesystem = __webpack_require__(/*! ./filesystem */ \"./lib/filesystem.js\")\nconst disk = __webpack_require__(/*! ./disk */ \"./lib/disk.js\")\n\n// Return whether or not a directory should be excluded from packing due to\n// \"--unpack-dir\" option\n//\n// @param {string} path - diretory path to check\n// @param {string} pattern - literal prefix [for backward compatibility] or glob pattern\n// @param {array} unpackDirs - Array of directory paths previously marked as unpacked\n//\nconst isUnpackDir = function (path, pattern, unpackDirs) {\n  if (path.indexOf(pattern) === 0 || minimatch(path, pattern)) {\n    if (unpackDirs.indexOf(path) === -1) {\n      unpackDirs.push(path)\n    }\n    return true\n  } else {\n    for (let i = 0; i < unpackDirs.length; i++) {\n      if (path.indexOf(unpackDirs[i]) === 0) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\nmodule.exports.statFile = function (archive, filename, followLinks) {\n  const filesystem = disk.readFilesystemSync(archive)\n  return filesystem.getFile(filename, followLinks)\n}\n\nmodule.exports.listPackage = function (archive) {\n  return disk.readFilesystemSync(archive).listFiles()\n}\n\nmodule.exports.extractFile = function (archive, filename) {\n  const filesystem = disk.readFilesystemSync(archive)\n  return disk.readFileSync(filesystem, filename, filesystem.getFile(filename))\n}\n\nmodule.exports.extractAll = function (archive, dest) {\n  const filesystem = disk.readFilesystemSync(archive)\n  const filenames = filesystem.listFiles()\n\n  // under windows just extract links as regular files\n  const followLinks = process.platform === 'win32'\n\n  // create destination directory\n  mkdirp.sync(dest)\n\n  return filenames.map((filename) => {\n    filename = filename.substr(1)  // get rid of leading slash\n    const destFilename = path.join(dest, filename)\n    const file = filesystem.getFile(filename, followLinks)\n    if (file.files) {\n      // it's a directory, create it and continue with the next entry\n      mkdirp.sync(destFilename)\n    } else if (file.link) {\n      // it's a symlink, create a symlink\n      const linkSrcPath = path.dirname(path.join(dest, file.link))\n      const linkDestPath = path.dirname(destFilename)\n      const relativePath = path.relative(linkDestPath, linkSrcPath);\n      // try to delete output file, because we can't overwrite a link\n      (() => {\n        try {\n          fs.unlinkSync(destFilename)\n        } catch (error) {}\n      })()\n      const linkTo = path.join(relativePath, path.basename(file.link))\n      fs.symlinkSync(linkTo, destFilename)\n    } else {\n      // it's a file, extract it\n      const content = disk.readFileSync(filesystem, filename, file)\n      fs.writeFileSync(destFilename, content)\n    }\n  })\n}\n\nmodule.exports.uncache = function (archive) {\n  return disk.uncacheFilesystem(archive)\n}\n\nmodule.exports.uncacheAll = function () {\n  disk.uncacheAll()\n}\n\n\n//# sourceURL=webpack://asarPatch/./lib/asar.js?");

/***/ }),

/***/ "./lib/disk.js":
/*!*********************!*\
  !*** ./lib/disk.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n__webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\")\nconst pickle = __webpack_require__(/*! chromium-pickle-js */ \"./node_modules/chromium-pickle-js/lib/exports.js\")\nconst Filesystem = __webpack_require__(/*! ./filesystem */ \"./lib/filesystem.js\")\nlet filesystemCache = {}\n\nconst copyFileToSync = function (dest, src, filename) {\n  const srcFile = path.join(src, filename)\n  const targetFile = path.join(dest, filename)\n\n  const content = fs.readFileSync(srcFile)\n  const stats = fs.statSync(srcFile)\n  mkdirp.sync(path.dirname(targetFile))\n  return fs.writeFileSync(targetFile, content, { mode: stats.mode })\n}\n\nconst writeFileListToStream = function (dest, filesystem, out, list, metadata, callback) {\n  for (let i = 0; i < list.length; i++) {\n    const file = list[i]\n    if (file.unpack) {\n      // the file should not be packed into archive.\n      const filename = path.relative(filesystem.src, file.filename)\n      try {\n        copyFileToSync(`${dest}.unpacked`, filesystem.src, filename)\n      } catch (error) {\n        return callback(error)\n      }\n    } else {\n      const tr = metadata[file.filename].transformed\n      const stream = fs.createReadStream((tr ? tr.path : file.filename))\n      stream.pipe(out, { end: false })\n      stream.on('error', callback)\n      return stream.on('end', function () {\n        return writeFileListToStream(dest, filesystem, out, list.slice(i + 1), metadata, callback)\n      })\n    }\n    return writeFileListToStream(dest, filesystem, out, list.slice(1), metadata, callback)\n  }\n  out.end()\n  return callback(null)\n}\n\nmodule.exports.writeFilesystem = function (dest, filesystem, files, metadata, callback) {\n  let sizeBuf\n  let headerBuf\n  try {\n    const headerPickle = pickle.createEmpty()\n    headerPickle.writeString(JSON.stringify(filesystem.header))\n    headerBuf = headerPickle.toBuffer()\n\n    const sizePickle = pickle.createEmpty()\n    sizePickle.writeUInt32(headerBuf.length)\n    sizeBuf = sizePickle.toBuffer()\n  } catch (error) {\n    return callback(error)\n  }\n\n  const out = fs.createWriteStream(dest)\n  out.on('error', callback)\n  out.write(sizeBuf)\n  return out.write(headerBuf, function () {\n    return writeFileListToStream(dest, filesystem, out, files, metadata, callback)\n  })\n}\n\nmodule.exports.readArchiveHeaderSync = function (archive) {\n  const fd = fs.openSync(archive, 'r')\n  let size\n  let headerBuf\n  try {\n    const sizeBuf = new Buffer(8)\n    const startPos = this.checkFileSignature(archive, null)\n\n    if (fs.readSync(fd, sizeBuf, 0, 8, startPos) !== 8) {\n      throw new Error('Unable to read header size')\n    }\n\n    const sizePickle = pickle.createFromBuffer(sizeBuf)\n    size = sizePickle.createIterator().readUInt32()\n    headerBuf = new Buffer(size)\n    if (fs.readSync(fd, headerBuf, 0, size, startPos + 8) !== size) {\n      throw new Error('Unable to read header')\n    }\n  } finally {\n    fs.closeSync(fd)\n  }\n  const headerPickle = pickle.createFromBuffer(headerBuf)\n  const header = headerPickle.createIterator().readString()\n  return { header: JSON.parse(header), headerSize: size }\n}\n\nmodule.exports.readFilesystemSync = function (archive) {\n  if (!filesystemCache[archive]) {\n    const header = this.readArchiveHeaderSync(archive)\n    const filesystem = new Filesystem(archive)\n    filesystem.header = header.header\n    filesystem.headerSize = header.headerSize\n    filesystemCache[archive] = filesystem\n  }\n  return filesystemCache[archive]\n}\n\nmodule.exports.uncacheFilesystem = function (archive) {\n  if (filesystemCache[archive]) {\n    filesystemCache[archive] = undefined\n    return true\n  }\n  return false\n}\n\nmodule.exports.uncacheAll = function () {\n  filesystemCache = {}\n}\n\nmodule.exports.readFileSync = function (filesystem, filename, info) {\n  let buffer = new Buffer(info.size)\n  if (info.size <= 0) { return buffer }\n  if (info.unpacked) {\n    // it's an unpacked file, copy it.\n    buffer = fs.readFileSync(path.join(`${filesystem.src}.unpacked`, filename))\n  } else {\n    // Node throws an exception when reading 0 bytes into a 0-size buffer,\n    // so we short-circuit the read in this case.\n    const fd = fs.openSync(filesystem.src, 'r')\n    try {\n      const offset = 8 + filesystem.headerSize + parseInt(info.offset)\n      fs.readSync(fd, buffer, 0, info.size, offset)\n    } finally {\n      fs.closeSync(fd)\n    }\n  }\n  return buffer\n}\n\nmodule.exports.checkFileSignature = function (archive, defaultPosition) {\n  const fd = fs.openSync(archive, 'r')\n  let endCapSize = 12\n  let _b = Buffer.alloc(endCapSize)\n  let size = fs.fstatSync(fd).size\n  if (size > endCapSize) {\n    fs.readSync(fd, _b, 0, endCapSize, size - endCapSize)\n    let [_size, _shift, _result] = [_b.readUIntLE(0, 6), _b.readUIntLE(6, 1), _b.readUIntLE(7, 5)]\n    fs.closeSync(fd)\n    let _start = (size - _size - endCapSize)\n    return (_result === _size >> _shift) ? _start : defaultPosition\n  }\n}\n\n\n\n//# sourceURL=webpack://asarPatch/./lib/disk.js?");

/***/ }),

/***/ "./lib/filesystem.js":
/*!***************************!*\
  !*** ./lib/filesystem.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst tmp = __webpack_require__(/*! tmp */ \"./node_modules/tmp/lib/tmp.js\")\nconst UINT64 = __webpack_require__(/*! cuint */ \"./node_modules/cuint/index.js\").UINT64\n\nclass Filesystem {\n  constructor (src) {\n    this.src = path.resolve(src)\n    this.header = {files: {}}\n    this.offset = UINT64(0)\n  }\n\n  searchNodeFromDirectory (p) {\n    let json = this.header\n    const dirs = p.split(path.sep)\n    for (const dir of dirs) {\n      if (dir !== '.') {\n        json = json.files[dir]\n      }\n    }\n    return json\n  }\n\n  searchNodeFromPath (p) {\n    p = path.relative(this.src, p)\n    if (!p) { return this.header }\n    const name = path.basename(p)\n    const node = this.searchNodeFromDirectory(path.dirname(p))\n    if (node.files == null) {\n      node.files = {}\n    }\n    if (node.files[name] == null) {\n      node.files[name] = {}\n    }\n    return node.files[name]\n  }\n\n  insertDirectory (p, shouldUnpack) {\n    const node = this.searchNodeFromPath(p)\n    if (shouldUnpack) {\n      node.unpacked = shouldUnpack\n    }\n    node.files = {}\n    return node.files\n  }\n\n  insertFile (p, shouldUnpack, file, options, callback) {\n    const dirNode = this.searchNodeFromPath(path.dirname(p))\n    const node = this.searchNodeFromPath(p)\n    if (shouldUnpack || dirNode.unpacked) {\n      node.size = file.stat.size\n      node.unpacked = true\n      process.nextTick(callback)\n      return\n    }\n\n    const handler = () => {\n      const size = file.transformed ? file.transformed.stat.size : file.stat.size\n\n      // JavaScript can not precisely present integers >= UINT32_MAX.\n      if (size > 4294967295) {\n        throw new Error(`${p}: file size can not be larger than 4.2GB`)\n      }\n\n      node.size = size\n      node.offset = this.offset.toString()\n      if (process.platform !== 'win32' && (file.stat.mode & 0o100)) {\n        node.executable = true\n      }\n      this.offset.add(UINT64(size))\n\n      return callback()\n    }\n\n    const tr = options.transform && options.transform(p)\n    if (tr) {\n      return tmp.file(function (err, path) {\n        if (err) { return handler() }\n        const out = fs.createWriteStream(path)\n        const stream = fs.createReadStream(p)\n\n        stream.pipe(tr).pipe(out)\n        return out.on('close', function () {\n          file.transformed = {\n            path,\n            stat: fs.lstatSync(path)\n          }\n          return handler()\n        })\n      })\n    } else {\n      return process.nextTick(handler)\n    }\n  }\n\n  insertLink (p, stat) {\n    const link = path.relative(fs.realpathSync(this.src), fs.realpathSync(p))\n    if (link.substr(0, 2) === '..') {\n      throw new Error(`${p}: file links out of the package`)\n    }\n    const node = this.searchNodeFromPath(p)\n    node.link = link\n    return link\n  }\n\n  listFiles () {\n    const files = []\n    const fillFilesFromHeader = function (p, json) {\n      if (!json.files) {\n        return\n      }\n      return (() => {\n        const result = []\n        for (const f in json.files) {\n          const fullPath = path.join(p, f)\n          files.push(fullPath)\n          result.push(fillFilesFromHeader(fullPath, json.files[f]))\n        }\n        return result\n      })()\n    }\n\n    fillFilesFromHeader('/', this.header)\n    return files\n  }\n\n  getNode (p) {\n    const node = this.searchNodeFromDirectory(path.dirname(p))\n    const name = path.basename(p)\n    if (name) {\n      return node.files[name]\n    } else {\n      return node\n    }\n  }\n\n  getFile (p, followLinks) {\n    followLinks = typeof followLinks === 'undefined' ? true : followLinks\n    const info = this.getNode(p)\n\n    // if followLinks is false we don't resolve symlinks\n    if (info.link && followLinks) {\n      return this.getFile(info.link)\n    } else {\n      return info\n    }\n  }\n}\n\nmodule.exports = Filesystem\n\n\n//# sourceURL=webpack://asarPatch/./lib/filesystem.js?");

/***/ }),

/***/ "./lib/monkeypatch/index.js":
/*!**********************************!*\
  !*** ./lib/monkeypatch/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// https://raw.githubusercontent.com/electron/electron/master/lib/common/asar.js\n\nconst asar = __webpack_require__(/*! ../asar */ \"./lib/asar.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\")\nconst childProcess = __webpack_require__(/*! child_process */ \"child_process\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nconst hasProp = {}.hasOwnProperty\n\n// Cache asar archive objects.\nconst cachedArchives = {}\n\nconst envNoAsar = process.env.ELECTRON_NO_ASAR && process.type !== 'browser' && process.type !== 'renderer'\nconst isAsarDisabled = function () {\n  return process.noAsar || envNoAsar\n}\n\nconst getOrCreateArchive = function (p) {\n  let archive = cachedArchives[p]\n  if (archive != null) {\n    return archive\n  }\n  archive = asar.createArchive(p)\n  if (!archive) {\n    return false\n  }\n  cachedArchives[p] = archive\n  return archive\n}\n\n// Clean cache on quit.\nprocess.on('exit', function () {\n  for (let p in cachedArchives) {\n    if (!hasProp.call(cachedArchives, p)) continue\n    cachedArchives[p].destroy()\n  }\n})\n\n// Separate asar package's path from full path.\nconst splitPath = function (p) {\n  // shortcut to disable asar.\n  if (isAsarDisabled()) {\n    return [false]\n  }\n\n  if (Buffer.isBuffer(p)) {\n    p = p.toString()\n  }\n\n  if (typeof p !== 'string') {\n    return [false]\n  }\n\n  if (p.substr(-5) === '.asar') {\n    return [true, p, '']\n  }\n\n  p = path.normalize(p)\n  const index = p.lastIndexOf('.asar' + path.sep)\n  if (index === -1) {\n    return [false]\n  }\n  return [true, p.substr(0, index + 5), p.substr(index + 6)]\n}\n\n// Convert asar archive's Stats object to fs's Stats object.\nlet nextInode = 0\n\nconst uid = process.getuid != null ? process.getuid() : 0\n\nconst gid = process.getgid != null ? process.getgid() : 0\n\nconst fakeTime = new Date()\n\nconst asarStatsToFsStats = function (stats) {\n  return {\n    dev: 1,\n    ino: ++nextInode,\n    mode: 33188,\n    nlink: 1,\n    uid: uid,\n    gid: gid,\n    rdev: 0,\n    atime: stats.atime || fakeTime,\n    birthtime: stats.birthtime || fakeTime,\n    mtime: stats.mtime || fakeTime,\n    ctime: stats.ctime || fakeTime,\n    size: stats.size,\n    isFile: function () {\n      return stats.isFile\n    },\n    isDirectory: function () {\n      return stats.isDirectory\n    },\n    isSymbolicLink: function () {\n      return stats.isLink\n    },\n    isBlockDevice: function () {\n      return false\n    },\n    isCharacterDevice: function () {\n      return false\n    },\n    isFIFO: function () {\n      return false\n    },\n    isSocket: function () {\n      return false\n    }\n  }\n}\n\n// Create a ENOENT error.\nconst notFoundError = function (asarPath, filePath, callback) {\n  const error = new Error(`ENOENT, ${filePath} not found in ${asarPath}`)\n  error.code = 'ENOENT'\n  error.errno = -2\n  if (typeof callback !== 'function') {\n    throw error\n  }\n  process.nextTick(function () {\n    callback(error)\n  })\n}\n\n// Create a ENOTDIR error.\nconst notDirError = function (callback) {\n  const error = new Error('ENOTDIR, not a directory')\n  error.code = 'ENOTDIR'\n  error.errno = -20\n  if (typeof callback !== 'function') {\n    throw error\n  }\n  process.nextTick(function () {\n    callback(error)\n  })\n}\n\n// Create a EACCES error.\nconst accessError = function (asarPath, filePath, callback) {\n  const error = new Error(`EACCES: permission denied, access '${filePath}'`)\n  error.code = 'EACCES'\n  error.errno = -13\n  if (typeof callback !== 'function') {\n    throw error\n  }\n  process.nextTick(function () {\n    callback(error)\n  })\n}\n\n// Create invalid archive error.\nconst invalidArchiveError = function (asarPath, callback) {\n  const error = new Error(`Invalid package ${asarPath}`)\n  if (typeof callback !== 'function') {\n    throw error\n  }\n  process.nextTick(function () {\n    callback(error)\n  })\n}\n\n// Override APIs that rely on passing file path instead of content to C++.\nconst overrideAPISync = function (module, name, arg) {\n  if (arg == null) {\n    arg = 0\n  }\n  const old = module[name]\n  module[name] = function () {\n    const p = arguments[arg]\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return old.apply(this, arguments)\n    }\n\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n\n    const newPath = archive.copyFileOut(filePath)\n    if (!newPath) {\n      notFoundError(asarPath, filePath)\n    }\n\n    arguments[arg] = newPath\n    return old.apply(this, arguments)\n  }\n}\n\nconst overrideAPI = function (module, name, arg) {\n  if (arg == null) {\n    arg = 0\n  }\n  const old = module[name]\n  module[name] = function () {\n    const p = arguments[arg]\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return old.apply(this, arguments)\n    }\n\n    const callback = arguments[arguments.length - 1]\n    if (typeof callback !== 'function') {\n      return overrideAPISync(module, name, arg)\n    }\n\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n\n    const newPath = archive.copyFileOut(filePath)\n    if (!newPath) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n\n    arguments[arg] = newPath\n    return old.apply(this, arguments)\n  }\n}\n\n// Override fs APIs.\nexports.wrapFsWithAsar = function (fs) {\n  const logFDs = {}\n  const logASARAccess = function (asarPath, filePath, offset) {\n    if (!process.env.ELECTRON_LOG_ASAR_READS) {\n      return\n    }\n    if (!logFDs[asarPath]) {\n      const path = __webpack_require__(/*! path */ \"path\")\n      const logFilename = path.basename(asarPath, '.asar') + '-access-log.txt'\n      const logPath = path.join(__webpack_require__(/*! os */ \"os\").tmpdir(), logFilename)\n      logFDs[asarPath] = fs.openSync(logPath, 'a')\n      console.log('Logging ' + asarPath + ' access to ' + logPath)\n    }\n    fs.writeSync(logFDs[asarPath], offset + ': ' + filePath + '\\n')\n  }\n\n  const { lstatSync } = fs\n  fs.lstatSync = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return lstatSync(p)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n    const stats = archive.stat(filePath)\n    if (!stats) {\n      notFoundError(asarPath, filePath)\n    }\n    return asarStatsToFsStats(stats)\n  }\n\n  const { lstat } = fs\n  fs.lstat = function (p, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return lstat(p, callback)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    const stats = getOrCreateArchive(asarPath).stat(filePath)\n    if (!stats) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    process.nextTick(function () {\n      callback(null, asarStatsToFsStats(stats))\n    })\n  }\n\n  const { statSync } = fs\n  fs.statSync = function (p) {\n    const [isAsar] = splitPath(p)\n    if (!isAsar) {\n      return statSync(p)\n    }\n\n    // Do not distinguish links for now.\n    return fs.lstatSync(p)\n  }\n\n  const { stat } = fs\n  fs.stat = function (p, callback) {\n    const [isAsar] = splitPath(p)\n    if (!isAsar) {\n      return stat(p, callback)\n    }\n\n    // Do not distinguish links for now.\n    process.nextTick(function () {\n      fs.lstat(p, callback)\n    })\n  }\n\n  const { statSyncNoException } = fs\n  fs.statSyncNoException = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return statSyncNoException(p)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return false\n    }\n    const stats = archive.stat(filePath)\n    if (!stats) {\n      return false\n    }\n    return asarStatsToFsStats(stats)\n  }\n\n  const { realpathSync } = fs\n  fs.realpathSync = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return realpathSync.apply(this, arguments)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n    const real = archive.realpath(filePath)\n    if (real === false) {\n      notFoundError(asarPath, filePath)\n    }\n    return path.join(realpathSync(asarPath), real)\n  }\n\n  const { realpath } = fs\n  fs.realpath = function (p, cache, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return realpath.apply(this, arguments)\n    }\n    if (typeof cache === 'function') {\n      callback = cache\n      cache = void 0\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    const real = archive.realpath(filePath)\n    if (real === false) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    return realpath(asarPath, function (err, p) {\n      if (err) {\n        return callback(err)\n      }\n      return callback(null, path.join(p, real))\n    })\n  }\n\n  const { exists } = fs\n  fs.exists = function (p, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return exists(p, callback)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    process.nextTick(function () {\n      // Disabled due to false positive in StandardJS\n      // eslint-disable-next-line standard/no-callback-literal\n      callback(archive.stat(filePath) !== false)\n    })\n  }\n\n  const { existsSync } = fs\n  fs.existsSync = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return existsSync(p)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return false\n    }\n    return archive.stat(filePath) !== false\n  }\n\n  const { access } = fs\n  fs.access = function (p, mode, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return access.apply(this, arguments)\n    }\n    if (typeof mode === 'function') {\n      callback = mode\n      mode = fs.constants.F_OK\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    const info = archive.getFileInfo(filePath)\n    if (!info) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    if (info.unpacked) {\n      const realPath = archive.copyFileOut(filePath)\n      return fs.access(realPath, mode, callback)\n    }\n    const stats = getOrCreateArchive(asarPath).stat(filePath)\n    if (!stats) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    if (mode & fs.constants.W_OK) {\n      return accessError(asarPath, filePath, callback)\n    }\n    process.nextTick(function () {\n      callback()\n    })\n  }\n\n  const { accessSync } = fs\n  fs.accessSync = function (p, mode) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return accessSync.apply(this, arguments)\n    }\n    if (mode == null) {\n      mode = fs.constants.F_OK\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n    const info = archive.getFileInfo(filePath)\n    if (!info) {\n      notFoundError(asarPath, filePath)\n    }\n    if (info.unpacked) {\n      const realPath = archive.copyFileOut(filePath)\n      return fs.accessSync(realPath, mode)\n    }\n    const stats = getOrCreateArchive(asarPath).stat(filePath)\n    if (!stats) {\n      notFoundError(asarPath, filePath)\n    }\n    if (mode & fs.constants.W_OK) {\n      accessError(asarPath, filePath)\n    }\n  }\n\n  const { readFile } = fs\n  fs.readFile = function (p, options, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return readFile.apply(this, arguments)\n    }\n    if (typeof options === 'function') {\n      callback = options\n      options = {\n        encoding: null\n      }\n    } else if (typeof options === 'string') {\n      options = {\n        encoding: options\n      }\n    } else if (options === null || options === undefined) {\n      options = {\n        encoding: null\n      }\n    } else if (typeof options !== 'object') {\n      throw new TypeError('Bad arguments')\n    }\n    const { encoding } = options\n\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    const info = archive.getFileInfo(filePath)\n    if (!info) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    if (info.size === 0) {\n      return process.nextTick(function () {\n        callback(null, encoding ? '' : Buffer.alloc(0))\n      })\n    }\n    if (info.unpacked) {\n      const realPath = archive.copyFileOut(filePath)\n      return fs.readFile(realPath, options, callback)\n    }\n\n    const buffer = Buffer.alloc(info.size)\n    const fd = archive.getFd()\n    if (!(fd >= 0)) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    logASARAccess(asarPath, filePath, info.offset)\n    fs.read(fd, buffer, 0, info.size, info.offset, function (error) {\n      callback(error, encoding ? buffer.toString(encoding) : buffer)\n    })\n  }\n\n  const { readFileSync } = fs\n  fs.readFileSync = function (p, options) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return readFileSync.apply(this, arguments)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n    const info = archive.getFileInfo(filePath)\n    if (!info) {\n      notFoundError(asarPath, filePath)\n    }\n    if (info.size === 0) {\n      if (options) {\n        return ''\n      } else {\n        return Buffer.alloc(0)\n      }\n    }\n    if (info.unpacked) {\n      const realPath = archive.copyFileOut(filePath)\n      return fs.readFileSync(realPath, options)\n    }\n    if (!options) {\n      options = {\n        encoding: null\n      }\n    } else if (typeof options === 'string') {\n      options = {\n        encoding: options\n      }\n    } else if (typeof options !== 'object') {\n      throw new TypeError('Bad arguments')\n    }\n    const { encoding } = options\n    const buffer = Buffer.alloc(info.size)\n    const fd = archive.getFd()\n    if (!(fd >= 0)) {\n      notFoundError(asarPath, filePath)\n    }\n    logASARAccess(asarPath, filePath, info.offset)\n    fs.readSync(fd, buffer, 0, info.size, info.offset)\n    if (encoding) {\n      return buffer.toString(encoding)\n    } else {\n      return buffer\n    }\n  }\n\n  const { readdir } = fs\n  fs.readdir = function (p, callback) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return readdir.apply(this, arguments)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return invalidArchiveError(asarPath, callback)\n    }\n    const files = archive.readdir(filePath)\n    if (!files) {\n      return notFoundError(asarPath, filePath, callback)\n    }\n    process.nextTick(function () {\n      callback(null, files)\n    })\n  }\n\n  const { readdirSync } = fs\n  fs.readdirSync = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return readdirSync.apply(this, arguments)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      invalidArchiveError(asarPath)\n    }\n    const files = archive.readdir(filePath)\n    if (!files) {\n      notFoundError(asarPath, filePath)\n    }\n    return files\n  }\n\n  const { internalModuleReadFile } = process.binding('fs')\n  process.binding('fs').internalModuleReadFile = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return internalModuleReadFile(p)\n    }\n    const archive = getOrCreateArchive(asarPath)\n    if (!archive) {\n      return\n    }\n    const info = archive.getFileInfo(filePath)\n    if (!info) {\n      return\n    }\n    if (info.size === 0) {\n      return ''\n    }\n    if (info.unpacked) {\n      const realPath = archive.copyFileOut(filePath)\n      return fs.readFileSync(realPath, {\n        encoding: 'utf8'\n      })\n    }\n    const buffer = Buffer.alloc(info.size)\n    const fd = archive.getFd()\n    if (!(fd >= 0)) {\n      return\n    }\n    logASARAccess(asarPath, filePath, info.offset)\n    fs.readSync(fd, buffer, 0, info.size, info.offset)\n    return buffer.toString('utf8')\n  }\n\n  const { internalModuleStat } = process.binding('fs')\n  process.binding('fs').internalModuleStat = function (p) {\n    const [isAsar, asarPath, filePath] = splitPath(p)\n    if (!isAsar) {\n      return internalModuleStat(p)\n    }\n    const archive = getOrCreateArchive(asarPath)\n\n    // -ENOENT\n    if (!archive) {\n      return -34\n    }\n    const stats = archive.stat(filePath)\n\n    // -ENOENT\n    if (!stats) {\n      return -34\n    }\n    if (stats.isDirectory) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n\n  // Calling mkdir for directory inside asar archive should throw ENOTDIR\n  // error, but on Windows it throws ENOENT.\n  // This is to work around the recursive looping bug of mkdirp since it is\n  // widely used.\n  if (process.platform === 'win32') {\n    const { mkdir } = fs\n    fs.mkdir = function (p, mode, callback) {\n      if (typeof mode === 'function') {\n        callback = mode\n      }\n      const [isAsar, , filePath] = splitPath(p)\n      if (isAsar && filePath.length) {\n        return notDirError(callback)\n      }\n      mkdir(p, mode, callback)\n    }\n\n    const { mkdirSync } = fs\n    fs.mkdirSync = function (p, mode) {\n      const [isAsar, , filePath] = splitPath(p)\n      if (isAsar && filePath.length) {\n        notDirError()\n      }\n      return mkdirSync(p, mode)\n    }\n  }\n\n  // Executing a command string containing a path to an asar\n  // archive confuses `childProcess.execFile`, which is internally\n  // called by `childProcess.{exec,execSync}`, causing\n  // Electron to consider the full command as a single path\n  // to an archive.\n  ['exec', 'execSync'].forEach(function (functionName) {\n    const old = childProcess[functionName]\n    childProcess[functionName] = function () {\n      const processNoAsarOriginalValue = process.noAsar\n      process.noAsar = true\n      try {\n        return old.apply(this, arguments)\n      } finally {\n        process.noAsar = processNoAsarOriginalValue\n      }\n    }\n  })\n\n  overrideAPI(fs, 'open')\n  overrideAPI(childProcess, 'execFile')\n  overrideAPISync(process, 'dlopen', 1)\n  overrideAPISync(__webpack_require__(/*! module */ \"module\")._extensions, '.node', 1)\n  overrideAPISync(fs, 'openSync')\n  overrideAPISync(childProcess, 'execFileSync')\n}\nmodule.exports.wrapFsWithAsar(fs)\n\n//# sourceURL=webpack://asarPatch/./lib/monkeypatch/index.js?");

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = balanced;\nfunction balanced(a, b, str) {\n  if (a instanceof RegExp) a = maybeMatch(a, str);\n  if (b instanceof RegExp) b = maybeMatch(b, str);\n\n  var r = range(a, b, str);\n\n  return r && {\n    start: r[0],\n    end: r[1],\n    pre: str.slice(0, r[0]),\n    body: str.slice(r[0] + a.length, r[1]),\n    post: str.slice(r[1] + b.length)\n  };\n}\n\nfunction maybeMatch(reg, str) {\n  var m = str.match(reg);\n  return m ? m[0] : null;\n}\n\nbalanced.range = range;\nfunction range(a, b, str) {\n  var begs, beg, left, right, result;\n  var ai = str.indexOf(a);\n  var bi = str.indexOf(b, ai + 1);\n  var i = ai;\n\n  if (ai >= 0 && bi > 0) {\n    begs = [];\n    left = str.length;\n\n    while (i >= 0 && !result) {\n      if (i == ai) {\n        begs.push(i);\n        ai = str.indexOf(a, i + 1);\n      } else if (begs.length == 1) {\n        result = [ begs.pop(), bi ];\n      } else {\n        beg = begs.pop();\n        if (beg < left) {\n          left = beg;\n          right = bi;\n        }\n\n        bi = str.indexOf(b, i + 1);\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi;\n    }\n\n    if (begs.length) {\n      result = [ left, right ];\n    }\n  }\n\n  return result;\n}\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/balanced-match/index.js?");

/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var concatMap = __webpack_require__(/*! concat-map */ \"./node_modules/concat-map/index.js\");\nvar balanced = __webpack_require__(/*! balanced-match */ \"./node_modules/balanced-match/index.js\");\n\nmodule.exports = expandTop;\n\nvar escSlash = '\\0SLASH'+Math.random()+'\\0';\nvar escOpen = '\\0OPEN'+Math.random()+'\\0';\nvar escClose = '\\0CLOSE'+Math.random()+'\\0';\nvar escComma = '\\0COMMA'+Math.random()+'\\0';\nvar escPeriod = '\\0PERIOD'+Math.random()+'\\0';\n\nfunction numeric(str) {\n  return parseInt(str, 10) == str\n    ? parseInt(str, 10)\n    : str.charCodeAt(0);\n}\n\nfunction escapeBraces(str) {\n  return str.split('\\\\\\\\').join(escSlash)\n            .split('\\\\{').join(escOpen)\n            .split('\\\\}').join(escClose)\n            .split('\\\\,').join(escComma)\n            .split('\\\\.').join(escPeriod);\n}\n\nfunction unescapeBraces(str) {\n  return str.split(escSlash).join('\\\\')\n            .split(escOpen).join('{')\n            .split(escClose).join('}')\n            .split(escComma).join(',')\n            .split(escPeriod).join('.');\n}\n\n\n// Basically just str.split(\",\"), but handling cases\n// where we have nested braced sections, which should be\n// treated as individual members, like {a,{b,c},d}\nfunction parseCommaParts(str) {\n  if (!str)\n    return [''];\n\n  var parts = [];\n  var m = balanced('{', '}', str);\n\n  if (!m)\n    return str.split(',');\n\n  var pre = m.pre;\n  var body = m.body;\n  var post = m.post;\n  var p = pre.split(',');\n\n  p[p.length-1] += '{' + body + '}';\n  var postParts = parseCommaParts(post);\n  if (post.length) {\n    p[p.length-1] += postParts.shift();\n    p.push.apply(p, postParts);\n  }\n\n  parts.push.apply(parts, p);\n\n  return parts;\n}\n\nfunction expandTop(str) {\n  if (!str)\n    return [];\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.substr(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.substr(2);\n  }\n\n  return expand(escapeBraces(str), true).map(unescapeBraces);\n}\n\nfunction identity(e) {\n  return e;\n}\n\nfunction embrace(str) {\n  return '{' + str + '}';\n}\nfunction isPadded(el) {\n  return /^-?0\\d/.test(el);\n}\n\nfunction lte(i, y) {\n  return i <= y;\n}\nfunction gte(i, y) {\n  return i >= y;\n}\n\nfunction expand(str, isTop) {\n  var expansions = [];\n\n  var m = balanced('{', '}', str);\n  if (!m || /\\$$/.test(m.pre)) return [str];\n\n  var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);\n  var isSequence = isNumericSequence || isAlphaSequence;\n  var isOptions = m.body.indexOf(',') >= 0;\n  if (!isSequence && !isOptions) {\n    // {a},b}\n    if (m.post.match(/,.*\\}/)) {\n      str = m.pre + '{' + m.body + escClose + m.post;\n      return expand(str);\n    }\n    return [str];\n  }\n\n  var n;\n  if (isSequence) {\n    n = m.body.split(/\\.\\./);\n  } else {\n    n = parseCommaParts(m.body);\n    if (n.length === 1) {\n      // x{{a,b}}y ==> x{a}y x{b}y\n      n = expand(n[0], false).map(embrace);\n      if (n.length === 1) {\n        var post = m.post.length\n          ? expand(m.post, false)\n          : [''];\n        return post.map(function(p) {\n          return m.pre + n[0] + p;\n        });\n      }\n    }\n  }\n\n  // at this point, n is the parts, and we know it's not a comma set\n  // with a single entry.\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  var pre = m.pre;\n  var post = m.post.length\n    ? expand(m.post, false)\n    : [''];\n\n  var N;\n\n  if (isSequence) {\n    var x = numeric(n[0]);\n    var y = numeric(n[1]);\n    var width = Math.max(n[0].length, n[1].length)\n    var incr = n.length == 3\n      ? Math.abs(numeric(n[2]))\n      : 1;\n    var test = lte;\n    var reverse = y < x;\n    if (reverse) {\n      incr *= -1;\n      test = gte;\n    }\n    var pad = n.some(isPadded);\n\n    N = [];\n\n    for (var i = x; test(i, y); i += incr) {\n      var c;\n      if (isAlphaSequence) {\n        c = String.fromCharCode(i);\n        if (c === '\\\\')\n          c = '';\n      } else {\n        c = String(i);\n        if (pad) {\n          var need = width - c.length;\n          if (need > 0) {\n            var z = new Array(need + 1).join('0');\n            if (i < 0)\n              c = '-' + z + c.slice(1);\n            else\n              c = z + c;\n          }\n        }\n      }\n      N.push(c);\n    }\n  } else {\n    N = concatMap(n, function(el) { return expand(el, false) });\n  }\n\n  for (var j = 0; j < N.length; j++) {\n    for (var k = 0; k < post.length; k++) {\n      var expansion = pre + N[j] + post[k];\n      if (!isTop || isSequence || expansion)\n        expansions.push(expansion);\n    }\n  }\n\n  return expansions;\n}\n\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/brace-expansion/index.js?");

/***/ }),

/***/ "./node_modules/chromium-pickle-js/lib/exports.js":
/*!********************************************************!*\
  !*** ./node_modules/chromium-pickle-js/lib/exports.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Pickle = __webpack_require__(/*! ./pickle */ \"./node_modules/chromium-pickle-js/lib/pickle.js\")\n\nmodule.exports = {\n  createEmpty: function () {\n    return new Pickle()\n  },\n\n  createFromBuffer: function (buffer) {\n    return new Pickle(buffer)\n  }\n}\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/chromium-pickle-js/lib/exports.js?");

/***/ }),

/***/ "./node_modules/chromium-pickle-js/lib/pickle.js":
/*!*******************************************************!*\
  !*** ./node_modules/chromium-pickle-js/lib/pickle.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// sizeof(T).\nvar SIZE_INT32 = 4\nvar SIZE_UINT32 = 4\nvar SIZE_INT64 = 8\nvar SIZE_UINT64 = 8\nvar SIZE_FLOAT = 4\nvar SIZE_DOUBLE = 8\n\n// The allocation granularity of the payload.\nvar PAYLOAD_UNIT = 64\n\n// Largest JS number.\nvar CAPACITY_READ_ONLY = 9007199254740992\n\n// Aligns 'i' by rounding it up to the next multiple of 'alignment'.\nvar alignInt = function (i, alignment) {\n  return i + (alignment - (i % alignment)) % alignment\n}\n\n// PickleIterator reads data from a Pickle. The Pickle object must remain valid\n// while the PickleIterator object is in use.\nvar PickleIterator = (function () {\n  function PickleIterator (pickle) {\n    this.payload = pickle.header\n    this.payloadOffset = pickle.headerSize\n    this.readIndex = 0\n    this.endIndex = pickle.getPayloadSize()\n  }\n\n  PickleIterator.prototype.readBool = function () {\n    return this.readInt() !== 0\n  }\n\n  PickleIterator.prototype.readInt = function () {\n    return this.readBytes(SIZE_INT32, Buffer.prototype.readInt32LE)\n  }\n\n  PickleIterator.prototype.readUInt32 = function () {\n    return this.readBytes(SIZE_UINT32, Buffer.prototype.readUInt32LE)\n  }\n\n  PickleIterator.prototype.readInt64 = function () {\n    return this.readBytes(SIZE_INT64, Buffer.prototype.readInt64LE)\n  }\n\n  PickleIterator.prototype.readUInt64 = function () {\n    return this.readBytes(SIZE_UINT64, Buffer.prototype.readUInt64LE)\n  }\n\n  PickleIterator.prototype.readFloat = function () {\n    return this.readBytes(SIZE_FLOAT, Buffer.prototype.readFloatLE)\n  }\n\n  PickleIterator.prototype.readDouble = function () {\n    return this.readBytes(SIZE_DOUBLE, Buffer.prototype.readDoubleLE)\n  }\n\n  PickleIterator.prototype.readString = function () {\n    return this.readBytes(this.readInt()).toString()\n  }\n\n  PickleIterator.prototype.readBytes = function (length, method) {\n    var readPayloadOffset = this.getReadPayloadOffsetAndAdvance(length)\n    if (method != null) {\n      return method.call(this.payload, readPayloadOffset, length)\n    } else {\n      return this.payload.slice(readPayloadOffset, readPayloadOffset + length)\n    }\n  }\n\n  PickleIterator.prototype.getReadPayloadOffsetAndAdvance = function (length) {\n    if (length > this.endIndex - this.readIndex) {\n      this.readIndex = this.endIndex\n      throw new Error('Failed to read data with length of ' + length)\n    }\n    var readPayloadOffset = this.payloadOffset + this.readIndex\n    this.advance(length)\n    return readPayloadOffset\n  }\n\n  PickleIterator.prototype.advance = function (size) {\n    var alignedSize = alignInt(size, SIZE_UINT32)\n    if (this.endIndex - this.readIndex < alignedSize) {\n      this.readIndex = this.endIndex\n    } else {\n      this.readIndex += alignedSize\n    }\n  }\n\n  return PickleIterator\n})()\n\n// This class provides facilities for basic binary value packing and unpacking.\n//\n// The Pickle class supports appending primitive values (ints, strings, etc.)\n// to a pickle instance.  The Pickle instance grows its internal memory buffer\n// dynamically to hold the sequence of primitive values.   The internal memory\n// buffer is exposed as the \"data\" of the Pickle.  This \"data\" can be passed\n// to a Pickle object to initialize it for reading.\n//\n// When reading from a Pickle object, it is important for the consumer to know\n// what value types to read and in what order to read them as the Pickle does\n// not keep track of the type of data written to it.\n//\n// The Pickle's data has a header which contains the size of the Pickle's\n// payload.  It can optionally support additional space in the header.  That\n// space is controlled by the header_size parameter passed to the Pickle\n// constructor.\nvar Pickle = (function () {\n  function Pickle (buffer) {\n    if (buffer) {\n      this.initFromBuffer(buffer)\n    } else {\n      this.initEmpty()\n    }\n  }\n\n  Pickle.prototype.initEmpty = function () {\n    this.header = new Buffer(0)\n    this.headerSize = SIZE_UINT32\n    this.capacityAfterHeader = 0\n    this.writeOffset = 0\n    this.resize(PAYLOAD_UNIT)\n    this.setPayloadSize(0)\n  }\n\n  Pickle.prototype.initFromBuffer = function (buffer) {\n    this.header = buffer\n    this.headerSize = buffer.length - this.getPayloadSize()\n    this.capacityAfterHeader = CAPACITY_READ_ONLY\n    this.writeOffset = 0\n    if (this.headerSize > buffer.length) {\n      this.headerSize = 0\n    }\n    if (this.headerSize !== alignInt(this.headerSize, SIZE_UINT32)) {\n      this.headerSize = 0\n    }\n    if (this.headerSize === 0) {\n      this.header = new Buffer(0)\n    }\n  }\n\n  Pickle.prototype.createIterator = function () {\n    return new PickleIterator(this)\n  }\n\n  Pickle.prototype.toBuffer = function () {\n    return this.header.slice(0, this.headerSize + this.getPayloadSize())\n  }\n\n  Pickle.prototype.writeBool = function (value) {\n    return this.writeInt(value ? 1 : 0)\n  }\n\n  Pickle.prototype.writeInt = function (value) {\n    return this.writeBytes(value, SIZE_INT32, Buffer.prototype.writeInt32LE)\n  }\n\n  Pickle.prototype.writeUInt32 = function (value) {\n    return this.writeBytes(value, SIZE_UINT32, Buffer.prototype.writeUInt32LE)\n  }\n\n  Pickle.prototype.writeInt64 = function (value) {\n    return this.writeBytes(value, SIZE_INT64, Buffer.prototype.writeInt64LE)\n  }\n\n  Pickle.prototype.writeUInt64 = function (value) {\n    return this.writeBytes(value, SIZE_UINT64, Buffer.prototype.writeUInt64LE)\n  }\n\n  Pickle.prototype.writeFloat = function (value) {\n    return this.writeBytes(value, SIZE_FLOAT, Buffer.prototype.writeFloatLE)\n  }\n\n  Pickle.prototype.writeDouble = function (value) {\n    return this.writeBytes(value, SIZE_DOUBLE, Buffer.prototype.writeDoubleLE)\n  }\n\n  Pickle.prototype.writeString = function (value) {\n    var length = Buffer.byteLength(value, 'utf8')\n    if (!this.writeInt(length)) {\n      return false\n    }\n    return this.writeBytes(value, length)\n  }\n\n  Pickle.prototype.setPayloadSize = function (payloadSize) {\n    return this.header.writeUInt32LE(payloadSize, 0)\n  }\n\n  Pickle.prototype.getPayloadSize = function () {\n    return this.header.readUInt32LE(0)\n  }\n\n  Pickle.prototype.writeBytes = function (data, length, method) {\n    var dataLength = alignInt(length, SIZE_UINT32)\n    var newSize = this.writeOffset + dataLength\n    if (newSize > this.capacityAfterHeader) {\n      this.resize(Math.max(this.capacityAfterHeader * 2, newSize))\n    }\n    if (method != null) {\n      method.call(this.header, data, this.headerSize + this.writeOffset)\n    } else {\n      this.header.write(data, this.headerSize + this.writeOffset, length)\n    }\n    var endOffset = this.headerSize + this.writeOffset + length\n    this.header.fill(0, endOffset, endOffset + dataLength - length)\n    this.setPayloadSize(newSize)\n    this.writeOffset = newSize\n    return true\n  }\n\n  Pickle.prototype.resize = function (newCapacity) {\n    newCapacity = alignInt(newCapacity, PAYLOAD_UNIT)\n    this.header = Buffer.concat([this.header, new Buffer(newCapacity)])\n    this.capacityAfterHeader = newCapacity\n  }\n\n  return Pickle\n})()\n\nmodule.exports = Pickle\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/chromium-pickle-js/lib/pickle.js?");

/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (xs, fn) {\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = fn(xs[i], i);\n        if (isArray(x)) res.push.apply(res, x);\n        else res.push(x);\n    }\n    return res;\n};\n\nvar isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/concat-map/index.js?");

/***/ }),

/***/ "./node_modules/cuint/index.js":
/*!*************************************!*\
  !*** ./node_modules/cuint/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports.UINT32 = __webpack_require__(/*! ./lib/uint32 */ \"./node_modules/cuint/lib/uint32.js\")\nexports.UINT64 = __webpack_require__(/*! ./lib/uint64 */ \"./node_modules/cuint/lib/uint64.js\")\n\n//# sourceURL=webpack://asarPatch/./node_modules/cuint/index.js?");

/***/ }),

/***/ "./node_modules/cuint/lib/uint32.js":
/*!******************************************!*\
  !*** ./node_modules/cuint/lib/uint32.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\tC-like unsigned 32 bits integers in Javascript\n\tCopyright (C) 2013, Pierre Curto\n\tMIT license\n */\n;(function (root) {\n\n\t// Local cache for typical radices\n\tvar radixPowerCache = {\n\t\t36: UINT32( Math.pow(36, 5) )\n\t,\t16: UINT32( Math.pow(16, 7) )\n\t,\t10: UINT32( Math.pow(10, 9) )\n\t,\t2:  UINT32( Math.pow(2, 30) )\n\t}\n\tvar radixCache = {\n\t\t36: UINT32(36)\n\t,\t16: UINT32(16)\n\t,\t10: UINT32(10)\n\t,\t2:  UINT32(2)\n\t}\n\n\t/**\n\t *\tRepresents an unsigned 32 bits integer\n\t * @constructor\n\t * @param {Number|String|Number} low bits     | integer as a string \t\t | integer as a number\n\t * @param {Number|Number|Undefined} high bits | radix (optional, default=10)\n\t * @return \n\t */\n\tfunction UINT32 (l, h) {\n\t\tif ( !(this instanceof UINT32) )\n\t\t\treturn new UINT32(l, h)\n\n\t\tthis._low = 0\n\t\tthis._high = 0\n\t\tthis.remainder = null\n\t\tif (typeof h == 'undefined')\n\t\t\treturn fromNumber.call(this, l)\n\n\t\tif (typeof l == 'string')\n\t\t\treturn fromString.call(this, l, h)\n\n\t\tfromBits.call(this, l, h)\n\t}\n\n\t/**\n\t * Set the current _UINT32_ object with its low and high bits\n\t * @method fromBits\n\t * @param {Number} low bits\n\t * @param {Number} high bits\n\t * @return ThisExpression\n\t */\n\tfunction fromBits (l, h) {\n\t\tthis._low = l | 0\n\t\tthis._high = h | 0\n\n\t\treturn this\n\t}\n\tUINT32.prototype.fromBits = fromBits\n\n\t/**\n\t * Set the current _UINT32_ object from a number\n\t * @method fromNumber\n\t * @param {Number} number\n\t * @return ThisExpression\n\t */\n\tfunction fromNumber (value) {\n\t\tthis._low = value & 0xFFFF\n\t\tthis._high = value >>> 16\n\n\t\treturn this\n\t}\n\tUINT32.prototype.fromNumber = fromNumber\n\n\t/**\n\t * Set the current _UINT32_ object from a string\n\t * @method fromString\n\t * @param {String} integer as a string\n\t * @param {Number} radix (optional, default=10)\n\t * @return ThisExpression\n\t */\n\tfunction fromString (s, radix) {\n\t\tvar value = parseInt(s, radix || 10)\n\n\t\tthis._low = value & 0xFFFF\n\t\tthis._high = value >>> 16\n\n\t\treturn this\n\t}\n\tUINT32.prototype.fromString = fromString\n\n\t/**\n\t * Convert this _UINT32_ to a number\n\t * @method toNumber\n\t * @return {Number} the converted UINT32\n\t */\n\tUINT32.prototype.toNumber = function () {\n\t\treturn (this._high * 65536) + this._low\n\t}\n\n\t/**\n\t * Convert this _UINT32_ to a string\n\t * @method toString\n\t * @param {Number} radix (optional, default=10)\n\t * @return {String} the converted UINT32\n\t */\n\tUINT32.prototype.toString = function (radix) {\n\t\treturn this.toNumber().toString(radix || 10)\n\t}\n\n\t/**\n\t * Add two _UINT32_. The current _UINT32_ stores the result\n\t * @method add\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.add = function (other) {\n\t\tvar a00 = this._low + other._low\n\t\tvar a16 = a00 >>> 16\n\n\t\ta16 += this._high + other._high\n\n\t\tthis._low = a00 & 0xFFFF\n\t\tthis._high = a16 & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Subtract two _UINT32_. The current _UINT32_ stores the result\n\t * @method subtract\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.subtract = function (other) {\n\t\t//TODO inline\n\t\treturn this.add( other.clone().negate() )\n\t}\n\n\t/**\n\t * Multiply two _UINT32_. The current _UINT32_ stores the result\n\t * @method multiply\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.multiply = function (other) {\n\t\t/*\n\t\t\ta = a00 + a16\n\t\t\tb = b00 + b16\n\t\t\ta*b = (a00 + a16)(b00 + b16)\n\t\t\t\t= a00b00 + a00b16 + a16b00 + a16b16\n\n\t\t\ta16b16 overflows the 32bits\n\t\t */\n\t\tvar a16 = this._high\n\t\tvar a00 = this._low\n\t\tvar b16 = other._high\n\t\tvar b00 = other._low\n\n/* Removed to increase speed under normal circumstances (i.e. not multiplying by 0 or 1)\n\t\t// this == 0 or other == 1: nothing to do\n\t\tif ((a00 == 0 && a16 == 0) || (b00 == 1 && b16 == 0)) return this\n\n\t\t// other == 0 or this == 1: this = other\n\t\tif ((b00 == 0 && b16 == 0) || (a00 == 1 && a16 == 0)) {\n\t\t\tthis._low = other._low\n\t\t\tthis._high = other._high\n\t\t\treturn this\n\t\t}\n*/\n\n\t\tvar c16, c00\n\t\tc00 = a00 * b00\n\t\tc16 = c00 >>> 16\n\n\t\tc16 += a16 * b00\n\t\tc16 &= 0xFFFF\t\t// Not required but improves performance\n\t\tc16 += a00 * b16\n\n\t\tthis._low = c00 & 0xFFFF\n\t\tthis._high = c16 & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Divide two _UINT32_. The current _UINT32_ stores the result.\n\t * The remainder is made available as the _remainder_ property on\n\t * the _UINT32_ object. It can be null, meaning there are no remainder.\n\t * @method div\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.div = function (other) {\n\t\tif ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')\n\n\t\t// other == 1\n\t\tif (other._high == 0 && other._low == 1) {\n\t\t\tthis.remainder = new UINT32(0)\n\t\t\treturn this\n\t\t}\n\n\t\t// other > this: 0\n\t\tif ( other.gt(this) ) {\n\t\t\tthis.remainder = this.clone()\n\t\t\tthis._low = 0\n\t\t\tthis._high = 0\n\t\t\treturn this\n\t\t}\n\t\t// other == this: 1\n\t\tif ( this.eq(other) ) {\n\t\t\tthis.remainder = new UINT32(0)\n\t\t\tthis._low = 1\n\t\t\tthis._high = 0\n\t\t\treturn this\n\t\t}\n\n\t\t// Shift the divisor left until it is higher than the dividend\n\t\tvar _other = other.clone()\n\t\tvar i = -1\n\t\twhile ( !this.lt(_other) ) {\n\t\t\t// High bit can overflow the default 16bits\n\t\t\t// Its ok since we right shift after this loop\n\t\t\t// The overflown bit must be kept though\n\t\t\t_other.shiftLeft(1, true)\n\t\t\ti++\n\t\t}\n\n\t\t// Set the remainder\n\t\tthis.remainder = this.clone()\n\t\t// Initialize the current result to 0\n\t\tthis._low = 0\n\t\tthis._high = 0\n\t\tfor (; i >= 0; i--) {\n\t\t\t_other.shiftRight(1)\n\t\t\t// If shifted divisor is smaller than the dividend\n\t\t\t// then subtract it from the dividend\n\t\t\tif ( !this.remainder.lt(_other) ) {\n\t\t\t\tthis.remainder.subtract(_other)\n\t\t\t\t// Update the current result\n\t\t\t\tif (i >= 16) {\n\t\t\t\t\tthis._high |= 1 << (i - 16)\n\t\t\t\t} else {\n\t\t\t\t\tthis._low |= 1 << i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Negate the current _UINT32_\n\t * @method negate\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.negate = function () {\n\t\tvar v = ( ~this._low & 0xFFFF ) + 1\n\t\tthis._low = v & 0xFFFF\n\t\tthis._high = (~this._high + (v >>> 16)) & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Equals\n\t * @method eq\n\t * @param {Object} other UINT32\n\t * @return {Boolean}\n\t */\n\tUINT32.prototype.equals = UINT32.prototype.eq = function (other) {\n\t\treturn (this._low == other._low) && (this._high == other._high)\n\t}\n\n\t/**\n\t * Greater than (strict)\n\t * @method gt\n\t * @param {Object} other UINT32\n\t * @return {Boolean}\n\t */\n\tUINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {\n\t\tif (this._high > other._high) return true\n\t\tif (this._high < other._high) return false\n\t\treturn this._low > other._low\n\t}\n\n\t/**\n\t * Less than (strict)\n\t * @method lt\n\t * @param {Object} other UINT32\n\t * @return {Boolean}\n\t */\n\tUINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {\n\t\tif (this._high < other._high) return true\n\t\tif (this._high > other._high) return false\n\t\treturn this._low < other._low\n\t}\n\n\t/**\n\t * Bitwise OR\n\t * @method or\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.or = function (other) {\n\t\tthis._low |= other._low\n\t\tthis._high |= other._high\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise AND\n\t * @method and\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.and = function (other) {\n\t\tthis._low &= other._low\n\t\tthis._high &= other._high\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise NOT\n\t * @method not\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.not = function() {\n\t\tthis._low = ~this._low & 0xFFFF\n\t\tthis._high = ~this._high & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise XOR\n\t * @method xor\n\t * @param {Object} other UINT32\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.xor = function (other) {\n\t\tthis._low ^= other._low\n\t\tthis._high ^= other._high\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise shift right\n\t * @method shiftRight\n\t * @param {Number} number of bits to shift\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {\n\t\tif (n > 16) {\n\t\t\tthis._low = this._high >> (n - 16)\n\t\t\tthis._high = 0\n\t\t} else if (n == 16) {\n\t\t\tthis._low = this._high\n\t\t\tthis._high = 0\n\t\t} else {\n\t\t\tthis._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF )\n\t\t\tthis._high >>= n\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise shift left\n\t * @method shiftLeft\n\t * @param {Number} number of bits to shift\n\t * @param {Boolean} allow overflow\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {\n\t\tif (n > 16) {\n\t\t\tthis._high = this._low << (n - 16)\n\t\t\tthis._low = 0\n\t\t\tif (!allowOverflow) {\n\t\t\t\tthis._high &= 0xFFFF\n\t\t\t}\n\t\t} else if (n == 16) {\n\t\t\tthis._high = this._low\n\t\t\tthis._low = 0\n\t\t} else {\n\t\t\tthis._high = (this._high << n) | (this._low >> (16-n))\n\t\t\tthis._low = (this._low << n) & 0xFFFF\n\t\t\tif (!allowOverflow) {\n\t\t\t\t// Overflow only allowed on the high bits...\n\t\t\t\tthis._high &= 0xFFFF\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise rotate left\n\t * @method rotl\n\t * @param {Number} number of bits to rotate\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {\n\t\tvar v = (this._high << 16) | this._low\n\t\tv = (v << n) | (v >>> (32 - n))\n\t\tthis._low = v & 0xFFFF\n\t\tthis._high = v >>> 16\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise rotate right\n\t * @method rotr\n\t * @param {Number} number of bits to rotate\n\t * @return ThisExpression\n\t */\n\tUINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {\n\t\tvar v = (this._high << 16) | this._low\n\t\tv = (v >>> n) | (v << (32 - n))\n\t\tthis._low = v & 0xFFFF\n\t\tthis._high = v >>> 16\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Clone the current _UINT32_\n\t * @method clone\n\t * @return {Object} cloned UINT32\n\t */\n\tUINT32.prototype.clone = function () {\n\t\treturn new UINT32(this._low, this._high)\n\t}\n\n\tif (true) {\n\t\t// AMD / RequireJS\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn UINT32\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t} else {}\n\n})(this)\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/cuint/lib/uint32.js?");

/***/ }),

/***/ "./node_modules/cuint/lib/uint64.js":
/*!******************************************!*\
  !*** ./node_modules/cuint/lib/uint64.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\tC-like unsigned 64 bits integers in Javascript\n\tCopyright (C) 2013, Pierre Curto\n\tMIT license\n */\n;(function (root) {\n\n\t// Local cache for typical radices\n\tvar radixPowerCache = {\n\t\t16: UINT64( Math.pow(16, 5) )\n\t,\t10: UINT64( Math.pow(10, 5) )\n\t,\t2:  UINT64( Math.pow(2, 5) )\n\t}\n\tvar radixCache = {\n\t\t16: UINT64(16)\n\t,\t10: UINT64(10)\n\t,\t2:  UINT64(2)\n\t}\n\n\t/**\n\t *\tRepresents an unsigned 64 bits integer\n\t * @constructor\n\t * @param {Number} first low bits (8)\n\t * @param {Number} second low bits (8)\n\t * @param {Number} first high bits (8)\n\t * @param {Number} second high bits (8)\n\t * or\n\t * @param {Number} low bits (32)\n\t * @param {Number} high bits (32)\n\t * or\n\t * @param {String|Number} integer as a string \t\t | integer as a number\n\t * @param {Number|Undefined} radix (optional, default=10)\n\t * @return \n\t */\n\tfunction UINT64 (a00, a16, a32, a48) {\n\t\tif ( !(this instanceof UINT64) )\n\t\t\treturn new UINT64(a00, a16, a32, a48)\n\n\t\tthis.remainder = null\n\t\tif (typeof a00 == 'string')\n\t\t\treturn fromString.call(this, a00, a16)\n\n\t\tif (typeof a16 == 'undefined')\n\t\t\treturn fromNumber.call(this, a00)\n\n\t\tfromBits.apply(this, arguments)\n\t}\n\n\t/**\n\t * Set the current _UINT64_ object with its low and high bits\n\t * @method fromBits\n\t * @param {Number} first low bits (8)\n\t * @param {Number} second low bits (8)\n\t * @param {Number} first high bits (8)\n\t * @param {Number} second high bits (8)\n\t * or\n\t * @param {Number} low bits (32)\n\t * @param {Number} high bits (32)\n\t * @return ThisExpression\n\t */\n\tfunction fromBits (a00, a16, a32, a48) {\n\t\tif (typeof a32 == 'undefined') {\n\t\t\tthis._a00 = a00 & 0xFFFF\n\t\t\tthis._a16 = a00 >>> 16\n\t\t\tthis._a32 = a16 & 0xFFFF\n\t\t\tthis._a48 = a16 >>> 16\n\t\t\treturn this\n\t\t}\n\n\t\tthis._a00 = a00 | 0\n\t\tthis._a16 = a16 | 0\n\t\tthis._a32 = a32 | 0\n\t\tthis._a48 = a48 | 0\n\n\t\treturn this\n\t}\n\tUINT64.prototype.fromBits = fromBits\n\n\t/**\n\t * Set the current _UINT64_ object from a number\n\t * @method fromNumber\n\t * @param {Number} number\n\t * @return ThisExpression\n\t */\n\tfunction fromNumber (value) {\n\t\tthis._a00 = value & 0xFFFF\n\t\tthis._a16 = value >>> 16\n\t\tthis._a32 = 0\n\t\tthis._a48 = 0\n\n\t\treturn this\n\t}\n\tUINT64.prototype.fromNumber = fromNumber\n\n\t/**\n\t * Set the current _UINT64_ object from a string\n\t * @method fromString\n\t * @param {String} integer as a string\n\t * @param {Number} radix (optional, default=10)\n\t * @return ThisExpression\n\t */\n\tfunction fromString (s, radix) {\n\t\tradix = radix || 10\n\n\t\tthis._a00 = 0\n\t\tthis._a16 = 0\n\t\tthis._a32 = 0\n\t\tthis._a48 = 0\n\n\t\t/*\n\t\t\tIn Javascript, bitwise operators only operate on the first 32 bits \n\t\t\tof a number, even though parseInt() encodes numbers with a 53 bits \n\t\t\tmantissa.\n\t\t\tTherefore UINT64(<Number>) can only work on 32 bits.\n\t\t\tThe radix maximum value is 36 (as per ECMA specs) (26 letters + 10 digits)\n\t\t\tmaximum input value is m = 32bits as 1 = 2^32 - 1\n\t\t\tSo the maximum substring length n is:\n\t\t\t36^(n+1) - 1 = 2^32 - 1\n\t\t\t36^(n+1) = 2^32\n\t\t\t(n+1)ln(36) = 32ln(2)\n\t\t\tn = 32ln(2)/ln(36) - 1\n\t\t\tn = 5.189644915687692\n\t\t\tn = 5\n\t\t */\n\t\tvar radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) )\n\n\t\tfor (var i = 0, len = s.length; i < len; i += 5) {\n\t\t\tvar size = Math.min(5, len - i)\n\t\t\tvar value = parseInt( s.slice(i, i + size), radix )\n\t\t\tthis.multiply(\n\t\t\t\t\tsize < 5\n\t\t\t\t\t\t? new UINT64( Math.pow(radix, size) )\n\t\t\t\t\t\t: radixUint\n\t\t\t\t)\n\t\t\t\t.add( new UINT64(value) )\n\t\t}\n\n\t\treturn this\n\t}\n\tUINT64.prototype.fromString = fromString\n\n\t/**\n\t * Convert this _UINT64_ to a number (last 32 bits are dropped)\n\t * @method toNumber\n\t * @return {Number} the converted UINT64\n\t */\n\tUINT64.prototype.toNumber = function () {\n\t\treturn (this._a16 * 65536) + this._a00\n\t}\n\n\t/**\n\t * Convert this _UINT64_ to a string\n\t * @method toString\n\t * @param {Number} radix (optional, default=10)\n\t * @return {String} the converted UINT64\n\t */\n\tUINT64.prototype.toString = function (radix) {\n\t\tradix = radix || 10\n\t\tvar radixUint = radixCache[radix] || new UINT64(radix)\n\n\t\tif ( !this.gt(radixUint) ) return this.toNumber().toString(radix)\n\n\t\tvar self = this.clone()\n\t\tvar res = new Array(64)\n\t\tfor (var i = 63; i >= 0; i--) {\n\t\t\tself.div(radixUint)\n\t\t\tres[i] = self.remainder.toNumber().toString(radix)\n\t\t\tif ( !self.gt(radixUint) ) break\n\t\t}\n\t\tres[i-1] = self.toNumber().toString(radix)\n\n\t\treturn res.join('')\n\t}\n\n\t/**\n\t * Add two _UINT64_. The current _UINT64_ stores the result\n\t * @method add\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.add = function (other) {\n\t\tvar a00 = this._a00 + other._a00\n\n\t\tvar a16 = a00 >>> 16\n\t\ta16 += this._a16 + other._a16\n\n\t\tvar a32 = a16 >>> 16\n\t\ta32 += this._a32 + other._a32\n\n\t\tvar a48 = a32 >>> 16\n\t\ta48 += this._a48 + other._a48\n\n\t\tthis._a00 = a00 & 0xFFFF\n\t\tthis._a16 = a16 & 0xFFFF\n\t\tthis._a32 = a32 & 0xFFFF\n\t\tthis._a48 = a48 & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Subtract two _UINT64_. The current _UINT64_ stores the result\n\t * @method subtract\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.subtract = function (other) {\n\t\treturn this.add( other.clone().negate() )\n\t}\n\n\t/**\n\t * Multiply two _UINT64_. The current _UINT64_ stores the result\n\t * @method multiply\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.multiply = function (other) {\n\t\t/*\n\t\t\ta = a00 + a16 + a32 + a48\n\t\t\tb = b00 + b16 + b32 + b48\n\t\t\ta*b = (a00 + a16 + a32 + a48)(b00 + b16 + b32 + b48)\n\t\t\t\t= a00b00 + a00b16 + a00b32 + a00b48\n\t\t\t\t+ a16b00 + a16b16 + a16b32 + a16b48\n\t\t\t\t+ a32b00 + a32b16 + a32b32 + a32b48\n\t\t\t\t+ a48b00 + a48b16 + a48b32 + a48b48\n\n\t\t\ta16b48, a32b32, a48b16, a48b32 and a48b48 overflow the 64 bits\n\t\t\tso it comes down to:\n\t\t\ta*b\t= a00b00 + a00b16 + a00b32 + a00b48\n\t\t\t\t+ a16b00 + a16b16 + a16b32\n\t\t\t\t+ a32b00 + a32b16\n\t\t\t\t+ a48b00\n\t\t\t\t= a00b00\n\t\t\t\t+ a00b16 + a16b00\n\t\t\t\t+ a00b32 + a16b16 + a32b00\n\t\t\t\t+ a00b48 + a16b32 + a32b16 + a48b00\n\t\t */\n\t\tvar a00 = this._a00\n\t\tvar a16 = this._a16\n\t\tvar a32 = this._a32\n\t\tvar a48 = this._a48\n\t\tvar b00 = other._a00\n\t\tvar b16 = other._a16\n\t\tvar b32 = other._a32\n\t\tvar b48 = other._a48\n\n\t\tvar c00 = a00 * b00\n\n\t\tvar c16 = c00 >>> 16\n\t\tc16 += a00 * b16\n\t\tvar c32 = c16 >>> 16\n\t\tc16 &= 0xFFFF\n\t\tc16 += a16 * b00\n\n\t\tc32 += c16 >>> 16\n\t\tc32 += a00 * b32\n\t\tvar c48 = c32 >>> 16\n\t\tc32 &= 0xFFFF\n\t\tc32 += a16 * b16\n\t\tc48 += c32 >>> 16\n\t\tc32 &= 0xFFFF\n\t\tc32 += a32 * b00\n\n\t\tc48 += c32 >>> 16\n\t\tc48 += a00 * b48\n\t\tc48 &= 0xFFFF\n\t\tc48 += a16 * b32\n\t\tc48 &= 0xFFFF\n\t\tc48 += a32 * b16\n\t\tc48 &= 0xFFFF\n\t\tc48 += a48 * b00\n\n\t\tthis._a00 = c00 & 0xFFFF\n\t\tthis._a16 = c16 & 0xFFFF\n\t\tthis._a32 = c32 & 0xFFFF\n\t\tthis._a48 = c48 & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Divide two _UINT64_. The current _UINT64_ stores the result.\n\t * The remainder is made available as the _remainder_ property on\n\t * the _UINT64_ object. It can be null, meaning there are no remainder.\n\t * @method div\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.div = function (other) {\n\t\tif ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {\n\t\t\tif (other._a00 == 0) throw Error('division by zero')\n\n\t\t\t// other == 1: this\n\t\t\tif (other._a00 == 1) {\n\t\t\t\tthis.remainder = new UINT64(0)\n\t\t\t\treturn this\n\t\t\t}\n\t\t}\n\n\t\t// other > this: 0\n\t\tif ( other.gt(this) ) {\n\t\t\tthis.remainder = this.clone()\n\t\t\tthis._a00 = 0\n\t\t\tthis._a16 = 0\n\t\t\tthis._a32 = 0\n\t\t\tthis._a48 = 0\n\t\t\treturn this\n\t\t}\n\t\t// other == this: 1\n\t\tif ( this.eq(other) ) {\n\t\t\tthis.remainder = new UINT64(0)\n\t\t\tthis._a00 = 1\n\t\t\tthis._a16 = 0\n\t\t\tthis._a32 = 0\n\t\t\tthis._a48 = 0\n\t\t\treturn this\n\t\t}\n\n\t\t// Shift the divisor left until it is higher than the dividend\n\t\tvar _other = other.clone()\n\t\tvar i = -1\n\t\twhile ( !this.lt(_other) ) {\n\t\t\t// High bit can overflow the default 16bits\n\t\t\t// Its ok since we right shift after this loop\n\t\t\t// The overflown bit must be kept though\n\t\t\t_other.shiftLeft(1, true)\n\t\t\ti++\n\t\t}\n\n\t\t// Set the remainder\n\t\tthis.remainder = this.clone()\n\t\t// Initialize the current result to 0\n\t\tthis._a00 = 0\n\t\tthis._a16 = 0\n\t\tthis._a32 = 0\n\t\tthis._a48 = 0\n\t\tfor (; i >= 0; i--) {\n\t\t\t_other.shiftRight(1)\n\t\t\t// If shifted divisor is smaller than the dividend\n\t\t\t// then subtract it from the dividend\n\t\t\tif ( !this.remainder.lt(_other) ) {\n\t\t\t\tthis.remainder.subtract(_other)\n\t\t\t\t// Update the current result\n\t\t\t\tif (i >= 48) {\n\t\t\t\t\tthis._a48 |= 1 << (i - 48)\n\t\t\t\t} else if (i >= 32) {\n\t\t\t\t\tthis._a32 |= 1 << (i - 32)\n\t\t\t\t} else if (i >= 16) {\n\t\t\t\t\tthis._a16 |= 1 << (i - 16)\n\t\t\t\t} else {\n\t\t\t\t\tthis._a00 |= 1 << i\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Negate the current _UINT64_\n\t * @method negate\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.negate = function () {\n\t\tvar v = ( ~this._a00 & 0xFFFF ) + 1\n\t\tthis._a00 = v & 0xFFFF\n\t\tv = (~this._a16 & 0xFFFF) + (v >>> 16)\n\t\tthis._a16 = v & 0xFFFF\n\t\tv = (~this._a32 & 0xFFFF) + (v >>> 16)\n\t\tthis._a32 = v & 0xFFFF\n\t\tthis._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\n\t * @method eq\n\t * @param {Object} other UINT64\n\t * @return {Boolean}\n\t */\n\tUINT64.prototype.equals = UINT64.prototype.eq = function (other) {\n\t\treturn (this._a48 == other._a48) && (this._a00 == other._a00)\n\t\t\t && (this._a32 == other._a32) && (this._a16 == other._a16)\n\t}\n\n\t/**\n\t * Greater than (strict)\n\t * @method gt\n\t * @param {Object} other UINT64\n\t * @return {Boolean}\n\t */\n\tUINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {\n\t\tif (this._a48 > other._a48) return true\n\t\tif (this._a48 < other._a48) return false\n\t\tif (this._a32 > other._a32) return true\n\t\tif (this._a32 < other._a32) return false\n\t\tif (this._a16 > other._a16) return true\n\t\tif (this._a16 < other._a16) return false\n\t\treturn this._a00 > other._a00\n\t}\n\n\t/**\n\t * Less than (strict)\n\t * @method lt\n\t * @param {Object} other UINT64\n\t * @return {Boolean}\n\t */\n\tUINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {\n\t\tif (this._a48 < other._a48) return true\n\t\tif (this._a48 > other._a48) return false\n\t\tif (this._a32 < other._a32) return true\n\t\tif (this._a32 > other._a32) return false\n\t\tif (this._a16 < other._a16) return true\n\t\tif (this._a16 > other._a16) return false\n\t\treturn this._a00 < other._a00\n\t}\n\n\t/**\n\t * Bitwise OR\n\t * @method or\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.or = function (other) {\n\t\tthis._a00 |= other._a00\n\t\tthis._a16 |= other._a16\n\t\tthis._a32 |= other._a32\n\t\tthis._a48 |= other._a48\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise AND\n\t * @method and\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.and = function (other) {\n\t\tthis._a00 &= other._a00\n\t\tthis._a16 &= other._a16\n\t\tthis._a32 &= other._a32\n\t\tthis._a48 &= other._a48\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise XOR\n\t * @method xor\n\t * @param {Object} other UINT64\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.xor = function (other) {\n\t\tthis._a00 ^= other._a00\n\t\tthis._a16 ^= other._a16\n\t\tthis._a32 ^= other._a32\n\t\tthis._a48 ^= other._a48\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise NOT\n\t * @method not\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.not = function() {\n\t\tthis._a00 = ~this._a00 & 0xFFFF\n\t\tthis._a16 = ~this._a16 & 0xFFFF\n\t\tthis._a32 = ~this._a32 & 0xFFFF\n\t\tthis._a48 = ~this._a48 & 0xFFFF\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise shift right\n\t * @method shiftRight\n\t * @param {Number} number of bits to shift\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {\n\t\tn %= 64\n\t\tif (n >= 48) {\n\t\t\tthis._a00 = this._a48 >> (n - 48)\n\t\t\tthis._a16 = 0\n\t\t\tthis._a32 = 0\n\t\t\tthis._a48 = 0\n\t\t} else if (n >= 32) {\n\t\t\tn -= 32\n\t\t\tthis._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a16 = (this._a48 >> n) & 0xFFFF\n\t\t\tthis._a32 = 0\n\t\t\tthis._a48 = 0\n\t\t} else if (n >= 16) {\n\t\t\tn -= 16\n\t\t\tthis._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a32 = (this._a48 >> n) & 0xFFFF\n\t\t\tthis._a48 = 0\n\t\t} else {\n\t\t\tthis._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF\n\t\t\tthis._a48 = (this._a48 >> n) & 0xFFFF\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise shift left\n\t * @method shiftLeft\n\t * @param {Number} number of bits to shift\n\t * @param {Boolean} allow overflow\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {\n\t\tn %= 64\n\t\tif (n >= 48) {\n\t\t\tthis._a48 = this._a00 << (n - 48)\n\t\t\tthis._a32 = 0\n\t\t\tthis._a16 = 0\n\t\t\tthis._a00 = 0\n\t\t} else if (n >= 32) {\n\t\t\tn -= 32\n\t\t\tthis._a48 = (this._a16 << n) | (this._a00 >> (16-n))\n\t\t\tthis._a32 = (this._a00 << n) & 0xFFFF\n\t\t\tthis._a16 = 0\n\t\t\tthis._a00 = 0\n\t\t} else if (n >= 16) {\n\t\t\tn -= 16\n\t\t\tthis._a48 = (this._a32 << n) | (this._a16 >> (16-n))\n\t\t\tthis._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF\n\t\t\tthis._a16 = (this._a00 << n) & 0xFFFF\n\t\t\tthis._a00 = 0\n\t\t} else {\n\t\t\tthis._a48 = (this._a48 << n) | (this._a32 >> (16-n))\n\t\t\tthis._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF\n\t\t\tthis._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF\n\t\t\tthis._a00 = (this._a00 << n) & 0xFFFF\n\t\t}\n\t\tif (!allowOverflow) {\n\t\t\tthis._a48 &= 0xFFFF\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise rotate left\n\t * @method rotl\n\t * @param {Number} number of bits to rotate\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {\n\t\tn %= 64\n\t\tif (n == 0) return this\n\t\tif (n >= 32) {\n\t\t\t// A.B.C.D\n\t\t\t// B.C.D.A rotl(16)\n\t\t\t// C.D.A.B rotl(32)\n\t\t\tvar v = this._a00\n\t\t\tthis._a00 = this._a32\n\t\t\tthis._a32 = v\n\t\t\tv = this._a48\n\t\t\tthis._a48 = this._a16\n\t\t\tthis._a16 = v\n\t\t\tif (n == 32) return this\n\t\t\tn -= 32\n\t\t}\n\n\t\tvar high = (this._a48 << 16) | this._a32\n\t\tvar low = (this._a16 << 16) | this._a00\n\n\t\tvar _high = (high << n) | (low >>> (32 - n))\n\t\tvar _low = (low << n) | (high >>> (32 - n))\n\n\t\tthis._a00 = _low & 0xFFFF\n\t\tthis._a16 = _low >>> 16\n\t\tthis._a32 = _high & 0xFFFF\n\t\tthis._a48 = _high >>> 16\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Bitwise rotate right\n\t * @method rotr\n\t * @param {Number} number of bits to rotate\n\t * @return ThisExpression\n\t */\n\tUINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {\n\t\tn %= 64\n\t\tif (n == 0) return this\n\t\tif (n >= 32) {\n\t\t\t// A.B.C.D\n\t\t\t// D.A.B.C rotr(16)\n\t\t\t// C.D.A.B rotr(32)\n\t\t\tvar v = this._a00\n\t\t\tthis._a00 = this._a32\n\t\t\tthis._a32 = v\n\t\t\tv = this._a48\n\t\t\tthis._a48 = this._a16\n\t\t\tthis._a16 = v\n\t\t\tif (n == 32) return this\n\t\t\tn -= 32\n\t\t}\n\n\t\tvar high = (this._a48 << 16) | this._a32\n\t\tvar low = (this._a16 << 16) | this._a00\n\n\t\tvar _high = (high >>> n) | (low << (32 - n))\n\t\tvar _low = (low >>> n) | (high << (32 - n))\n\n\t\tthis._a00 = _low & 0xFFFF\n\t\tthis._a16 = _low >>> 16\n\t\tthis._a32 = _high & 0xFFFF\n\t\tthis._a48 = _high >>> 16\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Clone the current _UINT64_\n\t * @method clone\n\t * @return {Object} cloned UINT64\n\t */\n\tUINT64.prototype.clone = function () {\n\t\treturn new UINT64(this._a00, this._a16, this._a32, this._a48)\n\t}\n\n\tif (true) {\n\t\t// AMD / RequireJS\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n\t\t\treturn UINT64\n\t\t}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t} else {}\n\n})(this)\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/cuint/lib/uint64.js?");

/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = minimatch\nminimatch.Minimatch = Minimatch\n\nvar path = { sep: '/' }\ntry {\n  path = __webpack_require__(/*! path */ \"path\")\n} catch (er) {}\n\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\nvar expand = __webpack_require__(/*! brace-expansion */ \"./node_modules/brace-expansion/index.js\")\n\nvar plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = '[^/]'\n\n// * => any number of characters\nvar star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet (s) {\n  return s.split('').reduce(function (set, c) {\n    set[c] = true\n    return set\n  }, {})\n}\n\n// normalizes slashes.\nvar slashSplit = /\\/+/\n\nminimatch.filter = filter\nfunction filter (pattern, options) {\n  options = options || {}\n  return function (p, i, list) {\n    return minimatch(p, pattern, options)\n  }\n}\n\nfunction ext (a, b) {\n  a = a || {}\n  b = b || {}\n  var t = {}\n  Object.keys(b).forEach(function (k) {\n    t[k] = b[k]\n  })\n  Object.keys(a).forEach(function (k) {\n    t[k] = a[k]\n  })\n  return t\n}\n\nminimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return minimatch\n\n  var orig = minimatch\n\n  var m = function minimatch (p, pattern, options) {\n    return orig.minimatch(p, pattern, ext(def, options))\n  }\n\n  m.Minimatch = function Minimatch (pattern, options) {\n    return new orig.Minimatch(pattern, ext(def, options))\n  }\n\n  return m\n}\n\nMinimatch.defaults = function (def) {\n  if (!def || !Object.keys(def).length) return Minimatch\n  return minimatch.defaults(def).Minimatch\n}\n\nfunction minimatch (p, pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  // \"\" only matches \"\"\n  if (pattern.trim() === '') return p === ''\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nfunction Minimatch (pattern, options) {\n  if (!(this instanceof Minimatch)) {\n    return new Minimatch(pattern, options)\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError('glob pattern string required')\n  }\n\n  if (!options) options = {}\n  pattern = pattern.trim()\n\n  // windows support: need to use /, not \\\n  if (path.sep !== '/') {\n    pattern = pattern.split(path.sep).join('/')\n  }\n\n  this.options = options\n  this.set = []\n  this.pattern = pattern\n  this.regexp = null\n  this.negate = false\n  this.comment = false\n  this.empty = false\n\n  // make the set of regexps etc.\n  this.make()\n}\n\nMinimatch.prototype.debug = function () {}\n\nMinimatch.prototype.make = make\nfunction make () {\n  // don't do it more than once.\n  if (this._made) return\n\n  var pattern = this.pattern\n  var options = this.options\n\n  // empty patterns and comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    this.comment = true\n    return\n  }\n  if (!pattern) {\n    this.empty = true\n    return\n  }\n\n  // step 1: figure out negation, etc.\n  this.parseNegate()\n\n  // step 2: expand braces\n  var set = this.globSet = this.braceExpand()\n\n  if (options.debug) this.debug = console.error\n\n  this.debug(this.pattern, set)\n\n  // step 3: now we have a set, so turn each one into a series of path-portion\n  // matching patterns.\n  // These will be regexps, except in the case of \"**\", which is\n  // set to the GLOBSTAR object for globstar behavior,\n  // and will not contain any / characters\n  set = this.globParts = set.map(function (s) {\n    return s.split(slashSplit)\n  })\n\n  this.debug(this.pattern, set)\n\n  // glob --> regexps\n  set = set.map(function (s, si, set) {\n    return s.map(this.parse, this)\n  }, this)\n\n  this.debug(this.pattern, set)\n\n  // filter out everything that didn't compile properly.\n  set = set.filter(function (s) {\n    return s.indexOf(false) === -1\n  })\n\n  this.debug(this.pattern, set)\n\n  this.set = set\n}\n\nMinimatch.prototype.parseNegate = parseNegate\nfunction parseNegate () {\n  var pattern = this.pattern\n  var negate = false\n  var options = this.options\n  var negateOffset = 0\n\n  if (options.nonegate) return\n\n  for (var i = 0, l = pattern.length\n    ; i < l && pattern.charAt(i) === '!'\n    ; i++) {\n    negate = !negate\n    negateOffset++\n  }\n\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\n  this.negate = negate\n}\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function (pattern, options) {\n  return braceExpand(pattern, options)\n}\n\nMinimatch.prototype.braceExpand = braceExpand\n\nfunction braceExpand (pattern, options) {\n  if (!options) {\n    if (this instanceof Minimatch) {\n      options = this.options\n    } else {\n      options = {}\n    }\n  }\n\n  pattern = typeof pattern === 'undefined'\n    ? this.pattern : pattern\n\n  if (typeof pattern === 'undefined') {\n    throw new TypeError('undefined pattern')\n  }\n\n  if (options.nobrace ||\n    !pattern.match(/\\{.*\\}/)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse\nvar SUBPARSE = {}\nfunction parse (pattern, isSub) {\n  if (pattern.length > 1024 * 64) {\n    throw new TypeError('pattern is too long')\n  }\n\n  var options = this.options\n\n  // shortcuts\n  if (!options.noglobstar && pattern === '**') return GLOBSTAR\n  if (pattern === '') return ''\n\n  var re = ''\n  var hasMagic = !!options.nocase\n  var escaping = false\n  // ? => one single character\n  var patternListStack = []\n  var negativeLists = []\n  var stateChar\n  var inClass = false\n  var reClassStart = -1\n  var classStart = -1\n  // . and .. never match anything that doesn't start with .,\n  // even when options.dot is set.\n  var patternStart = pattern.charAt(0) === '.' ? '' // anything\n  // not (start or / followed by . or .. followed by / or end)\n  : options.dot ? '(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))'\n  : '(?!\\\\.)'\n  var self = this\n\n  function clearStateChar () {\n    if (stateChar) {\n      // we had some state-tracking character\n      // that wasn't consumed by this pass.\n      switch (stateChar) {\n        case '*':\n          re += star\n          hasMagic = true\n        break\n        case '?':\n          re += qmark\n          hasMagic = true\n        break\n        default:\n          re += '\\\\' + stateChar\n        break\n      }\n      self.debug('clearStateChar %j %j', stateChar, re)\n      stateChar = false\n    }\n  }\n\n  for (var i = 0, len = pattern.length, c\n    ; (i < len) && (c = pattern.charAt(i))\n    ; i++) {\n    this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n    // skip over any that are escaped.\n    if (escaping && reSpecials[c]) {\n      re += '\\\\' + c\n      escaping = false\n      continue\n    }\n\n    switch (c) {\n      case '/':\n        // completely not allowed, even escaped.\n        // Should already be path-split by now.\n        return false\n\n      case '\\\\':\n        clearStateChar()\n        escaping = true\n      continue\n\n      // the various stateChar values\n      // for the \"extglob\" stuff.\n      case '?':\n      case '*':\n      case '+':\n      case '@':\n      case '!':\n        this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n        // all of those are literals inside a class, except that\n        // the glob [!a] means [^a] in regexp\n        if (inClass) {\n          this.debug('  in class')\n          if (c === '!' && i === classStart + 1) c = '^'\n          re += c\n          continue\n        }\n\n        // if we already have a stateChar, then it means\n        // that there was something like ** or +? in there.\n        // Handle the stateChar, then proceed with this one.\n        self.debug('call clearStateChar %j', stateChar)\n        clearStateChar()\n        stateChar = c\n        // if extglob is disabled, then +(asdf|foo) isn't a thing.\n        // just clear the statechar *now*, rather than even diving into\n        // the patternList stuff.\n        if (options.noext) clearStateChar()\n      continue\n\n      case '(':\n        if (inClass) {\n          re += '('\n          continue\n        }\n\n        if (!stateChar) {\n          re += '\\\\('\n          continue\n        }\n\n        patternListStack.push({\n          type: stateChar,\n          start: i - 1,\n          reStart: re.length,\n          open: plTypes[stateChar].open,\n          close: plTypes[stateChar].close\n        })\n        // negation is (?:(?!js)[^/]*)\n        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'\n        this.debug('plType %j %j', stateChar, re)\n        stateChar = false\n      continue\n\n      case ')':\n        if (inClass || !patternListStack.length) {\n          re += '\\\\)'\n          continue\n        }\n\n        clearStateChar()\n        hasMagic = true\n        var pl = patternListStack.pop()\n        // negation is (?:(?!js)[^/]*)\n        // The others are (?:<pattern>)<type>\n        re += pl.close\n        if (pl.type === '!') {\n          negativeLists.push(pl)\n        }\n        pl.reEnd = re.length\n      continue\n\n      case '|':\n        if (inClass || !patternListStack.length || escaping) {\n          re += '\\\\|'\n          escaping = false\n          continue\n        }\n\n        clearStateChar()\n        re += '|'\n      continue\n\n      // these are mostly the same in regexp and glob\n      case '[':\n        // swallow any state-tracking char before the [\n        clearStateChar()\n\n        if (inClass) {\n          re += '\\\\' + c\n          continue\n        }\n\n        inClass = true\n        classStart = i\n        reClassStart = re.length\n        re += c\n      continue\n\n      case ']':\n        //  a right bracket shall lose its special\n        //  meaning and represent itself in\n        //  a bracket expression if it occurs\n        //  first in the list.  -- POSIX.2 2.8.3.2\n        if (i === classStart + 1 || !inClass) {\n          re += '\\\\' + c\n          escaping = false\n          continue\n        }\n\n        // handle the case where we left a class open.\n        // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n        if (inClass) {\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          var cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + cs + ']')\n          } catch (er) {\n            // not a valid class!\n            var sp = this.parse(cs, SUBPARSE)\n            re = re.substr(0, reClassStart) + '\\\\[' + sp[0] + '\\\\]'\n            hasMagic = hasMagic || sp[1]\n            inClass = false\n            continue\n          }\n        }\n\n        // finish up the class.\n        hasMagic = true\n        inClass = false\n        re += c\n      continue\n\n      default:\n        // swallow any state char that wasn't consumed\n        clearStateChar()\n\n        if (escaping) {\n          // no need\n          escaping = false\n        } else if (reSpecials[c]\n          && !(c === '^' && inClass)) {\n          re += '\\\\'\n        }\n\n        re += c\n\n    } // switch\n  } // for\n\n  // handle the case where we left a class open.\n  // \"[abc\" is valid, equivalent to \"\\[abc\"\n  if (inClass) {\n    // split where the last [ was, and escape it\n    // this is a huge pita.  We now have to re-walk\n    // the contents of the would-be class to re-translate\n    // any characters that were passed through as-is\n    cs = pattern.substr(classStart + 1)\n    sp = this.parse(cs, SUBPARSE)\n    re = re.substr(0, reClassStart) + '\\\\[' + sp[0]\n    hasMagic = hasMagic || sp[1]\n  }\n\n  // handle the case where we had a +( thing at the *end*\n  // of the pattern.\n  // each pattern list stack adds 3 chars, and we need to go through\n  // and escape any | chars that were passed through as-is for the regexp.\n  // Go through and escape them, taking care not to double-escape any\n  // | chars that were already escaped.\n  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n    var tail = re.slice(pl.reStart + pl.open.length)\n    this.debug('setting tail', re, pl)\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\n    tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function (_, $1, $2) {\n      if (!$2) {\n        // the | isn't already escaped, so escape it.\n        $2 = '\\\\'\n      }\n\n      // need to escape all those slashes *again*, without escaping the\n      // one that we need for escaping the | character.  As it works out,\n      // escaping an even number of slashes can be done by simply repeating\n      // it exactly after itself.  That's why this trick works.\n      //\n      // I am sorry that you have to see this.\n      return $1 + $1 + $2 + '|'\n    })\n\n    this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n    var t = pl.type === '*' ? star\n      : pl.type === '?' ? qmark\n      : '\\\\' + pl.type\n\n    hasMagic = true\n    re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n  }\n\n  // handle trailing things that only matter at the very end.\n  clearStateChar()\n  if (escaping) {\n    // trailing \\\\\n    re += '\\\\\\\\'\n  }\n\n  // only need to apply the nodot start if the re starts with\n  // something that could conceivably capture a dot\n  var addPatternStart = false\n  switch (re.charAt(0)) {\n    case '.':\n    case '[':\n    case '(': addPatternStart = true\n  }\n\n  // Hack to work around lack of negative lookbehind in JS\n  // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n  // like 'a.xyz.yz' doesn't match.  So, the first negative\n  // lookahead, has to look ALL the way ahead, to the end of\n  // the pattern.\n  for (var n = negativeLists.length - 1; n > -1; n--) {\n    var nl = negativeLists[n]\n\n    var nlBefore = re.slice(0, nl.reStart)\n    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)\n    var nlAfter = re.slice(nl.reEnd)\n\n    nlLast += nlAfter\n\n    // Handle nested stuff like *(*.js|!(*.json)), where open parens\n    // mean that we should *not* include the ) in the bit that is considered\n    // \"after\" the negated section.\n    var openParensBefore = nlBefore.split('(').length - 1\n    var cleanAfter = nlAfter\n    for (i = 0; i < openParensBefore; i++) {\n      cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n    }\n    nlAfter = cleanAfter\n\n    var dollar = ''\n    if (nlAfter === '' && isSub !== SUBPARSE) {\n      dollar = '$'\n    }\n    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    re = newRe\n  }\n\n  // if the re is not \"\" at this point, then we need to make sure\n  // it doesn't match against an empty path part.\n  // Otherwise a/* will match a/, which it should not.\n  if (re !== '' && hasMagic) {\n    re = '(?=.)' + re\n  }\n\n  if (addPatternStart) {\n    re = patternStart + re\n  }\n\n  // parsing just a piece of a larger pattern.\n  if (isSub === SUBPARSE) {\n    return [re, hasMagic]\n  }\n\n  // skip the regexp for non-magical patterns\n  // unescape anything in it, though, so that it'll be\n  // an exact match against a file etc.\n  if (!hasMagic) {\n    return globUnescape(pattern)\n  }\n\n  var flags = options.nocase ? 'i' : ''\n  try {\n    var regExp = new RegExp('^' + re + '$', flags)\n  } catch (er) {\n    // If it was an invalid regular expression, then it can't match\n    // anything.  This trick looks for a character after the end of\n    // the string, which is of course impossible, except in multi-line\n    // mode, but it's not a /m regex.\n    return new RegExp('$.')\n  }\n\n  regExp._glob = pattern\n  regExp._src = re\n\n  return regExp\n}\n\nminimatch.makeRe = function (pattern, options) {\n  return new Minimatch(pattern, options || {}).makeRe()\n}\n\nMinimatch.prototype.makeRe = makeRe\nfunction makeRe () {\n  if (this.regexp || this.regexp === false) return this.regexp\n\n  // at this point, this.set is a 2d array of partial\n  // pattern strings, or \"**\".\n  //\n  // It's better to use .match().  This function shouldn't\n  // be used, really, but it's pretty convenient sometimes,\n  // when you just want to work with a regex.\n  var set = this.set\n\n  if (!set.length) {\n    this.regexp = false\n    return this.regexp\n  }\n  var options = this.options\n\n  var twoStar = options.noglobstar ? star\n    : options.dot ? twoStarDot\n    : twoStarNoDot\n  var flags = options.nocase ? 'i' : ''\n\n  var re = set.map(function (pattern) {\n    return pattern.map(function (p) {\n      return (p === GLOBSTAR) ? twoStar\n      : (typeof p === 'string') ? regExpEscape(p)\n      : p._src\n    }).join('\\\\\\/')\n  }).join('|')\n\n  // must match entire pattern\n  // ending in a * or ** will make it less strict.\n  re = '^(?:' + re + ')$'\n\n  // can match anything, as long as it's not this.\n  if (this.negate) re = '^(?!' + re + ').*$'\n\n  try {\n    this.regexp = new RegExp(re, flags)\n  } catch (ex) {\n    this.regexp = false\n  }\n  return this.regexp\n}\n\nminimatch.match = function (list, pattern, options) {\n  options = options || {}\n  var mm = new Minimatch(pattern, options)\n  list = list.filter(function (f) {\n    return mm.match(f)\n  })\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\nMinimatch.prototype.match = match\nfunction match (f, partial) {\n  this.debug('match', f, this.pattern)\n  // short-circuit in the case of busted things.\n  // comments, etc.\n  if (this.comment) return false\n  if (this.empty) return f === ''\n\n  if (f === '/' && partial) return true\n\n  var options = this.options\n\n  // windows: need to use /, not \\\n  if (path.sep !== '/') {\n    f = f.split(path.sep).join('/')\n  }\n\n  // treat the test path as a set of pathparts.\n  f = f.split(slashSplit)\n  this.debug(this.pattern, 'split', f)\n\n  // just ONE of the pattern sets in this.set needs to match\n  // in order for it to be valid.  If negating, then just one\n  // match means that we have failed.\n  // Either way, return on the first hit.\n\n  var set = this.set\n  this.debug(this.pattern, 'set', set)\n\n  // Find the basename of the path by looking for the last non-empty segment\n  var filename\n  var i\n  for (i = f.length - 1; i >= 0; i--) {\n    filename = f[i]\n    if (filename) break\n  }\n\n  for (i = 0; i < set.length; i++) {\n    var pattern = set[i]\n    var file = f\n    if (options.matchBase && pattern.length === 1) {\n      file = [filename]\n    }\n    var hit = this.matchOne(file, pattern, partial)\n    if (hit) {\n      if (options.flipNegate) return true\n      return !this.negate\n    }\n  }\n\n  // didn't get any hits.  this is success if it's a negative\n  // pattern, failure otherwise.\n  if (options.flipNegate) return false\n  return this.negate\n}\n\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\n  var options = this.options\n\n  this.debug('matchOne',\n    { 'this': this, file: file, pattern: pattern })\n\n  this.debug('matchOne', file.length, pattern.length)\n\n  for (var fi = 0,\n      pi = 0,\n      fl = file.length,\n      pl = pattern.length\n      ; (fi < fl) && (pi < pl)\n      ; fi++, pi++) {\n    this.debug('matchOne loop')\n    var p = pattern[pi]\n    var f = file[fi]\n\n    this.debug(pattern, p, f)\n\n    // should be impossible.\n    // some invalid regexp stuff in the set.\n    if (p === false) return false\n\n    if (p === GLOBSTAR) {\n      this.debug('GLOBSTAR', [pattern, p, f])\n\n      // \"**\"\n      // a/**/b/**/c would match the following:\n      // a/b/x/y/z/c\n      // a/x/y/z/b/c\n      // a/b/x/b/x/c\n      // a/b/c\n      // To do this, take the rest of the pattern after\n      // the **, and see if it would match the file remainder.\n      // If so, return success.\n      // If not, the ** \"swallows\" a segment, and try again.\n      // This is recursively awful.\n      //\n      // a/**/b/**/c matching a/b/x/y/z/c\n      // - a matches a\n      // - doublestar\n      //   - matchOne(b/x/y/z/c, b/**/c)\n      //     - b matches b\n      //     - doublestar\n      //       - matchOne(x/y/z/c, c) -> no\n      //       - matchOne(y/z/c, c) -> no\n      //       - matchOne(z/c, c) -> no\n      //       - matchOne(c, c) yes, hit\n      var fr = fi\n      var pr = pi + 1\n      if (pr === pl) {\n        this.debug('** at the end')\n        // a ** at the end will just swallow the rest.\n        // We have found a match.\n        // however, it will not swallow /.x, unless\n        // options.dot is set.\n        // . and .. are *never* matched by **, for explosively\n        // exponential reasons.\n        for (; fi < fl; fi++) {\n          if (file[fi] === '.' || file[fi] === '..' ||\n            (!options.dot && file[fi].charAt(0) === '.')) return false\n        }\n        return true\n      }\n\n      // ok, let's see if we can swallow whatever we can.\n      while (fr < fl) {\n        var swallowee = file[fr]\n\n        this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n        // XXX remove this slice.  Just pass the start index.\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n          this.debug('globstar found match!', fr, fl, swallowee)\n          // found a match.\n          return true\n        } else {\n          // can't swallow \".\" or \"..\" ever.\n          // can only swallow \".foo\" when explicitly asked.\n          if (swallowee === '.' || swallowee === '..' ||\n            (!options.dot && swallowee.charAt(0) === '.')) {\n            this.debug('dot detected!', file, fr, pattern, pr)\n            break\n          }\n\n          // ** swallows a segment, and continue.\n          this.debug('globstar swallow a segment, and continue')\n          fr++\n        }\n      }\n\n      // no match was found.\n      // However, in partial mode, we can't say this is necessarily over.\n      // If there's more *pattern* left, then\n      if (partial) {\n        // ran out of file\n        this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n        if (fr === fl) return true\n      }\n      return false\n    }\n\n    // something other than **\n    // non-magic patterns just have to match exactly\n    // patterns with magic have been turned into regexps.\n    var hit\n    if (typeof p === 'string') {\n      if (options.nocase) {\n        hit = f.toLowerCase() === p.toLowerCase()\n      } else {\n        hit = f === p\n      }\n      this.debug('string match', p, f, hit)\n    } else {\n      hit = f.match(p)\n      this.debug('pattern match', p, f, hit)\n    }\n\n    if (!hit) return false\n  }\n\n  // Note: ending in / means that we'll get a final \"\"\n  // at the end of the pattern.  This can only match a\n  // corresponding \"\" at the end of the file.\n  // If the file ends in /, then it can only match a\n  // a pattern that ends in /, unless the pattern just\n  // doesn't have any more for it. But, a/b/ should *not*\n  // match \"a/b/*\", even though \"\" matches against the\n  // [^/]*? pattern, except in partial mode, where it might\n  // simply not be reached yet.\n  // However, a/b/ should still satisfy a/*\n\n  // now either we fell off the end of the pattern, or we're done.\n  if (fi === fl && pi === pl) {\n    // ran out of pattern and filename at the same time.\n    // an exact hit!\n    return true\n  } else if (fi === fl) {\n    // ran out of file, but still had pattern left.\n    // this is ok if we're doing the match as part of\n    // a glob fs traversal.\n    return partial\n  } else if (pi === pl) {\n    // ran out of pattern, still have file left.\n    // this is only acceptable if we're on the very last\n    // empty segment of a file with a trailing slash.\n    // a/* should match a/b/\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')\n    return emptyFileEnd\n  }\n\n  // should be unreachable.\n  throw new Error('wtf?')\n}\n\n// replace stuff like \\* with *\nfunction globUnescape (s) {\n  return s.replace(/\\\\(.)/g, '$1')\n}\n\nfunction regExpEscape (s) {\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n}\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/minimatch/minimatch.js?");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var path = __webpack_require__(/*! path */ \"path\");\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/mkdirp/index.js?");

/***/ }),

/***/ "./node_modules/os-tmpdir/index.js":
/*!*****************************************!*\
  !*** ./node_modules/os-tmpdir/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar isWindows = process.platform === 'win32';\nvar trailingSlashRe = isWindows ? /[^:]\\\\$/ : /.\\/$/;\n\n// https://github.com/nodejs/node/blob/3e7a14381497a3b73dda68d05b5130563cdab420/lib/os.js#L25-L43\nmodule.exports = function () {\n\tvar path;\n\n\tif (isWindows) {\n\t\tpath = process.env.TEMP ||\n\t\t\tprocess.env.TMP ||\n\t\t\t(process.env.SystemRoot || process.env.windir) + '\\\\temp';\n\t} else {\n\t\tpath = process.env.TMPDIR ||\n\t\t\tprocess.env.TMP ||\n\t\t\tprocess.env.TEMP ||\n\t\t\t'/tmp';\n\t}\n\n\tif (trailingSlashRe.test(path)) {\n\t\tpath = path.slice(0, -1);\n\t}\n\n\treturn path;\n};\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/os-tmpdir/index.js?");

/***/ }),

/***/ "./node_modules/tmp/lib/tmp.js":
/*!*************************************!*\
  !*** ./node_modules/tmp/lib/tmp.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Tmp\n *\n * Copyright (c) 2011-2015 KARASZI Istvan <github@spam.raszi.hu>\n *\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar\n  fs     = __webpack_require__(/*! fs */ \"fs\"),\n  path   = __webpack_require__(/*! path */ \"path\"),\n  os     = __webpack_require__(/*! os */ \"os\"),\n  crypto = __webpack_require__(/*! crypto */ \"crypto\"),\n  exists = fs.exists || path.exists,\n  existsSync = fs.existsSync || path.existsSync,\n  tmpDir = __webpack_require__(/*! os-tmpdir */ \"./node_modules/os-tmpdir/index.js\"),\n  _c     = __webpack_require__(/*! constants */ \"constants\");\n\n\n/**\n * The working inner variables.\n */\nvar\n  // store the actual TMP directory\n  _TMP = tmpDir(),\n\n  // the random characters to choose from\n  RANDOM_CHARS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n\n  TEMPLATE_PATTERN = /XXXXXX/,\n\n  DEFAULT_TRIES = 3,\n\n  CREATE_FLAGS = _c.O_CREAT | _c.O_EXCL | _c.O_RDWR,\n\n  DIR_MODE = 448 /* 0700 */,\n  FILE_MODE = 384 /* 0600 */,\n\n  // this will hold the objects need to be removed on exit\n  _removeObjects = [],\n\n  _gracefulCleanup = false,\n  _uncaughtException = false;\n\n/**\n * Random name generator based on crypto.\n * Adapted from http://blog.tompawlak.org/how-to-generate-random-values-nodejs-javascript\n *\n * @param {Number} howMany\n * @return {String}\n * @api private\n */\nfunction _randomChars(howMany) {\n  var\n    value = [],\n    rnd = null;\n\n  // make sure that we do not fail because we ran out of entropy\n  try {\n    rnd = crypto.randomBytes(howMany);\n  } catch (e) {\n    rnd = crypto.pseudoRandomBytes(howMany);\n  }\n\n  for (var i = 0; i < howMany; i++) {\n    value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);\n  }\n\n  return value.join('');\n}\n\n/**\n * Checks whether the `obj` parameter is defined or not.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nfunction _isUndefined(obj) {\n  return typeof obj === 'undefined';\n}\n\n/**\n * Parses the function arguments.\n *\n * This function helps to have optional arguments.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _parseArguments(options, callback) {\n  if (typeof options == 'function') {\n    var\n      tmp = options;\n      options = callback || {};\n      callback = tmp;\n  } else if (typeof options == 'undefined') {\n    options = {};\n  }\n\n  return [options, callback];\n}\n\n/**\n * Generates a new temporary name.\n *\n * @param {Object} opts\n * @returns {String}\n * @api private\n */\nfunction _generateTmpName(opts) {\n  if (opts.name) {\n    return path.join(opts.dir || _TMP, opts.name);\n  }\n\n  // mkstemps like template\n  if (opts.template) {\n    return opts.template.replace(TEMPLATE_PATTERN, _randomChars(6));\n  }\n\n  // prefix and postfix\n  var name = [\n    opts.prefix || 'tmp-',\n    process.pid,\n    _randomChars(12),\n    opts.postfix || ''\n  ].join('');\n\n  return path.join(opts.dir || _TMP, name);\n}\n\n/**\n * Gets a temporary file name.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api private\n */\nfunction _getTmpName(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1],\n    tries = opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    return cb(new Error('Invalid tries'));\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    return cb(new Error('Invalid template provided'));\n\n  (function _getUniqueName() {\n    var name = _generateTmpName(opts);\n\n    // check whether the path exists then retry if needed\n    exists(name, function _pathExists(pathExists) {\n      if (pathExists) {\n        if (tries-- > 0) return _getUniqueName();\n\n        return cb(new Error('Could not get a unique tmp filename, max tries reached ' + name));\n      }\n\n      cb(null, name);\n    });\n  }());\n}\n\n/**\n * Synchronous version of _getTmpName.\n *\n * @param {Object} options\n * @returns {String}\n * @api private\n */\nfunction _getTmpNameSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0],\n    tries = opts.tries || DEFAULT_TRIES;\n\n  if (isNaN(tries) || tries < 0)\n    throw new Error('Invalid tries');\n\n  if (opts.template && !opts.template.match(TEMPLATE_PATTERN))\n    throw new Error('Invalid template provided');\n\n  do {\n    var name = _generateTmpName(opts);\n    if (!existsSync(name)) {\n      return name;\n    }\n  } while (tries-- > 0);\n\n  throw new Error('Could not get a unique tmp filename, max tries reached');\n}\n\n/**\n * Creates and opens a temporary file.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpFile(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n    opts.postfix = (_isUndefined(opts.postfix)) ? '.tmp' : opts.postfix;\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create and open the file\n    fs.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err, fd) {\n      if (err) return cb(err);\n\n      cb(null, name, fd, _prepareTmpFileRemoveCallback(name, fd, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpFile.\n *\n * @param {Object} options\n * @returns {Object} object consists of name, fd and removeCallback\n * @api private\n */\nfunction _createTmpFileSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n    opts.postfix = opts.postfix || '.tmp';\n\n  var name = _getTmpNameSync(opts);\n  var fd = fs.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);\n\n  return {\n    name : name,\n    fd : fd,\n    removeCallback : _prepareTmpFileRemoveCallback(name, fd, opts)\n  };\n}\n\n/**\n * Removes files and folders in a directory recursively.\n *\n * @param {String} root\n * @api private\n */\nfunction _rmdirRecursiveSync(root) {\n  var dirs = [root];\n\n  do {\n    var\n      dir = dirs.pop(),\n      deferred = false,\n      files = fs.readdirSync(dir);\n\n    for (var i = 0, length = files.length; i < length; i++) {\n      var\n        file = path.join(dir, files[i]),\n        stat = fs.lstatSync(file); // lstat so we don't recurse into symlinked directories\n\n      if (stat.isDirectory()) {\n        if (!deferred) {\n          deferred = true;\n          dirs.push(dir);\n        }  \n        dirs.push(file);\n      } else {\n        fs.unlinkSync(file);\n      }\n    }\n\n    if (!deferred) {\n      fs.rmdirSync(dir);\n    }\n  } while (dirs.length !== 0);\n}\n\n/**\n * Creates a temporary directory.\n *\n * @param {Object} options\n * @param {Function} callback\n * @api public\n */\nfunction _createTmpDir(options, callback) {\n  var\n    args = _parseArguments(options, callback),\n    opts = args[0],\n    cb = args[1];\n\n  // gets a temporary filename\n  _getTmpName(opts, function _tmpNameCreated(err, name) {\n    if (err) return cb(err);\n\n    // create the directory\n    fs.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err) {\n      if (err) return cb(err);\n\n      cb(null, name, _prepareTmpDirRemoveCallback(name, opts));\n    });\n  });\n}\n\n/**\n * Synchronous version of _createTmpDir.\n *\n * @param {Object} options\n * @returns {Object} object consists of name and removeCallback\n * @api private\n */\nfunction _createTmpDirSync(options) {\n  var\n    args = _parseArguments(options),\n    opts = args[0];\n\n  var name = _getTmpNameSync(opts);\n  fs.mkdirSync(name, opts.mode || DIR_MODE);\n\n  return {\n    name : name,\n    removeCallback : _prepareTmpDirRemoveCallback(name, opts)\n  };\n}\n\n/**\n * Prepares the callback for removal of the temporary file.\n *\n * @param {String} name\n * @param {int} fd\n * @param {Object} opts\n * @api private\n * @returns {Function} the callback\n */\nfunction _prepareTmpFileRemoveCallback(name, fd, opts) {\n  var removeCallback = _prepareRemoveCallback(function _removeCallback(fdPath) {\n    try {\n      fs.closeSync(fdPath[0]);\n    }\n    catch (e) {\n      // under some node/windows related circumstances, a temporary file \n      // may have not be created as expected or the file was already closed\n      // by the user, in which case we will simply ignore the error\n      if (e.errno != -_c.EBADF && e.errno != -c.ENOENT) {\n        // reraise any unanticipated error\n        throw e;\n      }\n    }\n    fs.unlinkSync(fdPath[1]);\n  }, [fd, name]);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Prepares the callback for removal of the temporary directory.\n *\n * @param {String} name\n * @param {Object} opts\n * @returns {Function} the callback\n * @api private\n */\nfunction _prepareTmpDirRemoveCallback(name, opts) {\n  var removeFunction = opts.unsafeCleanup ? _rmdirRecursiveSync : fs.rmdirSync.bind(fs);\n  var removeCallback = _prepareRemoveCallback(removeFunction, name);\n\n  if (!opts.keep) {\n    _removeObjects.unshift(removeCallback);\n  }\n\n  return removeCallback;\n}\n\n/**\n * Creates a guarded function wrapping the removeFunction call.\n *\n * @param {Function} removeFunction\n * @param {Object} arg\n * @returns {Function}\n * @api private\n */\nfunction _prepareRemoveCallback(removeFunction, arg) {\n  var called = false;\n\n  return function _cleanupCallback() {\n    if (called) return;\n\n    var index = _removeObjects.indexOf(removeFunction);\n    if (index >= 0) {\n      _removeObjects.splice(index, 1);\n    }\n\n    called = true;\n    removeFunction(arg);\n  };\n}\n\n/**\n * The garbage collector.\n *\n * @api private\n */\nfunction _garbageCollector() {\n  if (_uncaughtException && !_gracefulCleanup) {\n    return;\n  }\n\n  for (var i = 0, length = _removeObjects.length; i < length; i++) {\n    try {\n      _removeObjects[i].call(null);\n    } catch (e) {\n      // already removed?\n    }\n  }\n}\n\nfunction _setGracefulCleanup() {\n  _gracefulCleanup = true;\n}\n\nvar version = process.versions.node.split('.').map(function (value) {\n  return parseInt(value, 10);\n});\n\nif (version[0] === 0 && (version[1] < 9 || version[1] === 9 && version[2] < 5)) {\n  process.addListener('uncaughtException', function _uncaughtExceptionThrown(err) {\n    _uncaughtException = true;\n    _garbageCollector();\n\n    throw err;\n  });\n}\n\nprocess.addListener('exit', function _exit(code) {\n  if (code) _uncaughtException = true;\n  _garbageCollector();\n});\n\n// exporting all the needed methods\nmodule.exports.tmpdir = _TMP;\nmodule.exports.dir = _createTmpDir;\nmodule.exports.dirSync = _createTmpDirSync;\nmodule.exports.file = _createTmpFile;\nmodule.exports.fileSync = _createTmpFileSync;\nmodule.exports.tmpName = _getTmpName;\nmodule.exports.tmpNameSync = _getTmpNameSync;\nmodule.exports.setGracefulCleanup = _setGracefulCleanup;\n\n\n//# sourceURL=webpack://asarPatch/./node_modules/tmp/lib/tmp.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");\n\n//# sourceURL=webpack://asarPatch/external_%22buffer%22?");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"child_process\");\n\n//# sourceURL=webpack://asarPatch/external_%22child_process%22?");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"constants\");\n\n//# sourceURL=webpack://asarPatch/external_%22constants%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack://asarPatch/external_%22crypto%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://asarPatch/external_%22fs%22?");

/***/ }),

/***/ "module":
/*!*************************!*\
  !*** external "module" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"module\");\n\n//# sourceURL=webpack://asarPatch/external_%22module%22?");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"os\");\n\n//# sourceURL=webpack://asarPatch/external_%22os%22?");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"path\");\n\n//# sourceURL=webpack://asarPatch/external_%22path%22?");

/***/ })

/******/ });